// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocked

//go:generate minimock -i route256/cart/internal/api.CartService -o cart_service_mock.go -n CartServiceMock -p mocked

import (
	"context"
	"route256/cart/internal/models"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// CartServiceMock implements mm_api.CartService
type CartServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddProduct          func(ctx context.Context, userID int64, sku int64, count uint32) (err error)
	funcAddProductOrigin    string
	inspectFuncAddProduct   func(ctx context.Context, userID int64, sku int64, count uint32)
	afterAddProductCounter  uint64
	beforeAddProductCounter uint64
	AddProductMock          mCartServiceMockAddProduct

	funcCart          func(ctx context.Context, userID int64) (cp1 *models.Cart, err error)
	funcCartOrigin    string
	inspectFuncCart   func(ctx context.Context, userID int64)
	afterCartCounter  uint64
	beforeCartCounter uint64
	CartMock          mCartServiceMockCart

	funcCheckout          func(ctx context.Context, userID int64) (i1 int64, err error)
	funcCheckoutOrigin    string
	inspectFuncCheckout   func(ctx context.Context, userID int64)
	afterCheckoutCounter  uint64
	beforeCheckoutCounter uint64
	CheckoutMock          mCartServiceMockCheckout

	funcClearCart          func(userID int64) (b1 bool)
	funcClearCartOrigin    string
	inspectFuncClearCart   func(userID int64)
	afterClearCartCounter  uint64
	beforeClearCartCounter uint64
	ClearCartMock          mCartServiceMockClearCart

	funcDeleteProduct          func(ctx context.Context, userID int64, sku int64) (err error)
	funcDeleteProductOrigin    string
	inspectFuncDeleteProduct   func(ctx context.Context, userID int64, sku int64)
	afterDeleteProductCounter  uint64
	beforeDeleteProductCounter uint64
	DeleteProductMock          mCartServiceMockDeleteProduct
}

// NewCartServiceMock returns a mock for mm_api.CartService
func NewCartServiceMock(t minimock.Tester) *CartServiceMock {
	m := &CartServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddProductMock = mCartServiceMockAddProduct{mock: m}
	m.AddProductMock.callArgs = []*CartServiceMockAddProductParams{}

	m.CartMock = mCartServiceMockCart{mock: m}
	m.CartMock.callArgs = []*CartServiceMockCartParams{}

	m.CheckoutMock = mCartServiceMockCheckout{mock: m}
	m.CheckoutMock.callArgs = []*CartServiceMockCheckoutParams{}

	m.ClearCartMock = mCartServiceMockClearCart{mock: m}
	m.ClearCartMock.callArgs = []*CartServiceMockClearCartParams{}

	m.DeleteProductMock = mCartServiceMockDeleteProduct{mock: m}
	m.DeleteProductMock.callArgs = []*CartServiceMockDeleteProductParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mCartServiceMockAddProduct struct {
	optional           bool
	mock               *CartServiceMock
	defaultExpectation *CartServiceMockAddProductExpectation
	expectations       []*CartServiceMockAddProductExpectation

	callArgs []*CartServiceMockAddProductParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartServiceMockAddProductExpectation specifies expectation struct of the CartService.AddProduct
type CartServiceMockAddProductExpectation struct {
	mock               *CartServiceMock
	params             *CartServiceMockAddProductParams
	paramPtrs          *CartServiceMockAddProductParamPtrs
	expectationOrigins CartServiceMockAddProductExpectationOrigins
	results            *CartServiceMockAddProductResults
	returnOrigin       string
	Counter            uint64
}

// CartServiceMockAddProductParams contains parameters of the CartService.AddProduct
type CartServiceMockAddProductParams struct {
	ctx    context.Context
	userID int64
	sku    int64
	count  uint32
}

// CartServiceMockAddProductParamPtrs contains pointers to parameters of the CartService.AddProduct
type CartServiceMockAddProductParamPtrs struct {
	ctx    *context.Context
	userID *int64
	sku    *int64
	count  *uint32
}

// CartServiceMockAddProductResults contains results of the CartService.AddProduct
type CartServiceMockAddProductResults struct {
	err error
}

// CartServiceMockAddProductOrigins contains origins of expectations of the CartService.AddProduct
type CartServiceMockAddProductExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
	originSku    string
	originCount  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddProduct *mCartServiceMockAddProduct) Optional() *mCartServiceMockAddProduct {
	mmAddProduct.optional = true
	return mmAddProduct
}

// Expect sets up expected params for CartService.AddProduct
func (mmAddProduct *mCartServiceMockAddProduct) Expect(ctx context.Context, userID int64, sku int64, count uint32) *mCartServiceMockAddProduct {
	if mmAddProduct.mock.funcAddProduct != nil {
		mmAddProduct.mock.t.Fatalf("CartServiceMock.AddProduct mock is already set by Set")
	}

	if mmAddProduct.defaultExpectation == nil {
		mmAddProduct.defaultExpectation = &CartServiceMockAddProductExpectation{}
	}

	if mmAddProduct.defaultExpectation.paramPtrs != nil {
		mmAddProduct.mock.t.Fatalf("CartServiceMock.AddProduct mock is already set by ExpectParams functions")
	}

	mmAddProduct.defaultExpectation.params = &CartServiceMockAddProductParams{ctx, userID, sku, count}
	mmAddProduct.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddProduct.expectations {
		if minimock.Equal(e.params, mmAddProduct.defaultExpectation.params) {
			mmAddProduct.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddProduct.defaultExpectation.params)
		}
	}

	return mmAddProduct
}

// ExpectCtxParam1 sets up expected param ctx for CartService.AddProduct
func (mmAddProduct *mCartServiceMockAddProduct) ExpectCtxParam1(ctx context.Context) *mCartServiceMockAddProduct {
	if mmAddProduct.mock.funcAddProduct != nil {
		mmAddProduct.mock.t.Fatalf("CartServiceMock.AddProduct mock is already set by Set")
	}

	if mmAddProduct.defaultExpectation == nil {
		mmAddProduct.defaultExpectation = &CartServiceMockAddProductExpectation{}
	}

	if mmAddProduct.defaultExpectation.params != nil {
		mmAddProduct.mock.t.Fatalf("CartServiceMock.AddProduct mock is already set by Expect")
	}

	if mmAddProduct.defaultExpectation.paramPtrs == nil {
		mmAddProduct.defaultExpectation.paramPtrs = &CartServiceMockAddProductParamPtrs{}
	}
	mmAddProduct.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddProduct.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddProduct
}

// ExpectUserIDParam2 sets up expected param userID for CartService.AddProduct
func (mmAddProduct *mCartServiceMockAddProduct) ExpectUserIDParam2(userID int64) *mCartServiceMockAddProduct {
	if mmAddProduct.mock.funcAddProduct != nil {
		mmAddProduct.mock.t.Fatalf("CartServiceMock.AddProduct mock is already set by Set")
	}

	if mmAddProduct.defaultExpectation == nil {
		mmAddProduct.defaultExpectation = &CartServiceMockAddProductExpectation{}
	}

	if mmAddProduct.defaultExpectation.params != nil {
		mmAddProduct.mock.t.Fatalf("CartServiceMock.AddProduct mock is already set by Expect")
	}

	if mmAddProduct.defaultExpectation.paramPtrs == nil {
		mmAddProduct.defaultExpectation.paramPtrs = &CartServiceMockAddProductParamPtrs{}
	}
	mmAddProduct.defaultExpectation.paramPtrs.userID = &userID
	mmAddProduct.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmAddProduct
}

// ExpectSkuParam3 sets up expected param sku for CartService.AddProduct
func (mmAddProduct *mCartServiceMockAddProduct) ExpectSkuParam3(sku int64) *mCartServiceMockAddProduct {
	if mmAddProduct.mock.funcAddProduct != nil {
		mmAddProduct.mock.t.Fatalf("CartServiceMock.AddProduct mock is already set by Set")
	}

	if mmAddProduct.defaultExpectation == nil {
		mmAddProduct.defaultExpectation = &CartServiceMockAddProductExpectation{}
	}

	if mmAddProduct.defaultExpectation.params != nil {
		mmAddProduct.mock.t.Fatalf("CartServiceMock.AddProduct mock is already set by Expect")
	}

	if mmAddProduct.defaultExpectation.paramPtrs == nil {
		mmAddProduct.defaultExpectation.paramPtrs = &CartServiceMockAddProductParamPtrs{}
	}
	mmAddProduct.defaultExpectation.paramPtrs.sku = &sku
	mmAddProduct.defaultExpectation.expectationOrigins.originSku = minimock.CallerInfo(1)

	return mmAddProduct
}

// ExpectCountParam4 sets up expected param count for CartService.AddProduct
func (mmAddProduct *mCartServiceMockAddProduct) ExpectCountParam4(count uint32) *mCartServiceMockAddProduct {
	if mmAddProduct.mock.funcAddProduct != nil {
		mmAddProduct.mock.t.Fatalf("CartServiceMock.AddProduct mock is already set by Set")
	}

	if mmAddProduct.defaultExpectation == nil {
		mmAddProduct.defaultExpectation = &CartServiceMockAddProductExpectation{}
	}

	if mmAddProduct.defaultExpectation.params != nil {
		mmAddProduct.mock.t.Fatalf("CartServiceMock.AddProduct mock is already set by Expect")
	}

	if mmAddProduct.defaultExpectation.paramPtrs == nil {
		mmAddProduct.defaultExpectation.paramPtrs = &CartServiceMockAddProductParamPtrs{}
	}
	mmAddProduct.defaultExpectation.paramPtrs.count = &count
	mmAddProduct.defaultExpectation.expectationOrigins.originCount = minimock.CallerInfo(1)

	return mmAddProduct
}

// Inspect accepts an inspector function that has same arguments as the CartService.AddProduct
func (mmAddProduct *mCartServiceMockAddProduct) Inspect(f func(ctx context.Context, userID int64, sku int64, count uint32)) *mCartServiceMockAddProduct {
	if mmAddProduct.mock.inspectFuncAddProduct != nil {
		mmAddProduct.mock.t.Fatalf("Inspect function is already set for CartServiceMock.AddProduct")
	}

	mmAddProduct.mock.inspectFuncAddProduct = f

	return mmAddProduct
}

// Return sets up results that will be returned by CartService.AddProduct
func (mmAddProduct *mCartServiceMockAddProduct) Return(err error) *CartServiceMock {
	if mmAddProduct.mock.funcAddProduct != nil {
		mmAddProduct.mock.t.Fatalf("CartServiceMock.AddProduct mock is already set by Set")
	}

	if mmAddProduct.defaultExpectation == nil {
		mmAddProduct.defaultExpectation = &CartServiceMockAddProductExpectation{mock: mmAddProduct.mock}
	}
	mmAddProduct.defaultExpectation.results = &CartServiceMockAddProductResults{err}
	mmAddProduct.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddProduct.mock
}

// Set uses given function f to mock the CartService.AddProduct method
func (mmAddProduct *mCartServiceMockAddProduct) Set(f func(ctx context.Context, userID int64, sku int64, count uint32) (err error)) *CartServiceMock {
	if mmAddProduct.defaultExpectation != nil {
		mmAddProduct.mock.t.Fatalf("Default expectation is already set for the CartService.AddProduct method")
	}

	if len(mmAddProduct.expectations) > 0 {
		mmAddProduct.mock.t.Fatalf("Some expectations are already set for the CartService.AddProduct method")
	}

	mmAddProduct.mock.funcAddProduct = f
	mmAddProduct.mock.funcAddProductOrigin = minimock.CallerInfo(1)
	return mmAddProduct.mock
}

// When sets expectation for the CartService.AddProduct which will trigger the result defined by the following
// Then helper
func (mmAddProduct *mCartServiceMockAddProduct) When(ctx context.Context, userID int64, sku int64, count uint32) *CartServiceMockAddProductExpectation {
	if mmAddProduct.mock.funcAddProduct != nil {
		mmAddProduct.mock.t.Fatalf("CartServiceMock.AddProduct mock is already set by Set")
	}

	expectation := &CartServiceMockAddProductExpectation{
		mock:               mmAddProduct.mock,
		params:             &CartServiceMockAddProductParams{ctx, userID, sku, count},
		expectationOrigins: CartServiceMockAddProductExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddProduct.expectations = append(mmAddProduct.expectations, expectation)
	return expectation
}

// Then sets up CartService.AddProduct return parameters for the expectation previously defined by the When method
func (e *CartServiceMockAddProductExpectation) Then(err error) *CartServiceMock {
	e.results = &CartServiceMockAddProductResults{err}
	return e.mock
}

// Times sets number of times CartService.AddProduct should be invoked
func (mmAddProduct *mCartServiceMockAddProduct) Times(n uint64) *mCartServiceMockAddProduct {
	if n == 0 {
		mmAddProduct.mock.t.Fatalf("Times of CartServiceMock.AddProduct mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddProduct.expectedInvocations, n)
	mmAddProduct.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddProduct
}

func (mmAddProduct *mCartServiceMockAddProduct) invocationsDone() bool {
	if len(mmAddProduct.expectations) == 0 && mmAddProduct.defaultExpectation == nil && mmAddProduct.mock.funcAddProduct == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddProduct.mock.afterAddProductCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddProduct.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddProduct implements mm_api.CartService
func (mmAddProduct *CartServiceMock) AddProduct(ctx context.Context, userID int64, sku int64, count uint32) (err error) {
	mm_atomic.AddUint64(&mmAddProduct.beforeAddProductCounter, 1)
	defer mm_atomic.AddUint64(&mmAddProduct.afterAddProductCounter, 1)

	mmAddProduct.t.Helper()

	if mmAddProduct.inspectFuncAddProduct != nil {
		mmAddProduct.inspectFuncAddProduct(ctx, userID, sku, count)
	}

	mm_params := CartServiceMockAddProductParams{ctx, userID, sku, count}

	// Record call args
	mmAddProduct.AddProductMock.mutex.Lock()
	mmAddProduct.AddProductMock.callArgs = append(mmAddProduct.AddProductMock.callArgs, &mm_params)
	mmAddProduct.AddProductMock.mutex.Unlock()

	for _, e := range mmAddProduct.AddProductMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddProduct.AddProductMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddProduct.AddProductMock.defaultExpectation.Counter, 1)
		mm_want := mmAddProduct.AddProductMock.defaultExpectation.params
		mm_want_ptrs := mmAddProduct.AddProductMock.defaultExpectation.paramPtrs

		mm_got := CartServiceMockAddProductParams{ctx, userID, sku, count}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddProduct.t.Errorf("CartServiceMock.AddProduct got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddProduct.AddProductMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmAddProduct.t.Errorf("CartServiceMock.AddProduct got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddProduct.AddProductMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.sku != nil && !minimock.Equal(*mm_want_ptrs.sku, mm_got.sku) {
				mmAddProduct.t.Errorf("CartServiceMock.AddProduct got unexpected parameter sku, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddProduct.AddProductMock.defaultExpectation.expectationOrigins.originSku, *mm_want_ptrs.sku, mm_got.sku, minimock.Diff(*mm_want_ptrs.sku, mm_got.sku))
			}

			if mm_want_ptrs.count != nil && !minimock.Equal(*mm_want_ptrs.count, mm_got.count) {
				mmAddProduct.t.Errorf("CartServiceMock.AddProduct got unexpected parameter count, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddProduct.AddProductMock.defaultExpectation.expectationOrigins.originCount, *mm_want_ptrs.count, mm_got.count, minimock.Diff(*mm_want_ptrs.count, mm_got.count))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddProduct.t.Errorf("CartServiceMock.AddProduct got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddProduct.AddProductMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddProduct.AddProductMock.defaultExpectation.results
		if mm_results == nil {
			mmAddProduct.t.Fatal("No results are set for the CartServiceMock.AddProduct")
		}
		return (*mm_results).err
	}
	if mmAddProduct.funcAddProduct != nil {
		return mmAddProduct.funcAddProduct(ctx, userID, sku, count)
	}
	mmAddProduct.t.Fatalf("Unexpected call to CartServiceMock.AddProduct. %v %v %v %v", ctx, userID, sku, count)
	return
}

// AddProductAfterCounter returns a count of finished CartServiceMock.AddProduct invocations
func (mmAddProduct *CartServiceMock) AddProductAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddProduct.afterAddProductCounter)
}

// AddProductBeforeCounter returns a count of CartServiceMock.AddProduct invocations
func (mmAddProduct *CartServiceMock) AddProductBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddProduct.beforeAddProductCounter)
}

// Calls returns a list of arguments used in each call to CartServiceMock.AddProduct.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddProduct *mCartServiceMockAddProduct) Calls() []*CartServiceMockAddProductParams {
	mmAddProduct.mutex.RLock()

	argCopy := make([]*CartServiceMockAddProductParams, len(mmAddProduct.callArgs))
	copy(argCopy, mmAddProduct.callArgs)

	mmAddProduct.mutex.RUnlock()

	return argCopy
}

// MinimockAddProductDone returns true if the count of the AddProduct invocations corresponds
// the number of defined expectations
func (m *CartServiceMock) MinimockAddProductDone() bool {
	if m.AddProductMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddProductMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddProductMock.invocationsDone()
}

// MinimockAddProductInspect logs each unmet expectation
func (m *CartServiceMock) MinimockAddProductInspect() {
	for _, e := range m.AddProductMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartServiceMock.AddProduct at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddProductCounter := mm_atomic.LoadUint64(&m.afterAddProductCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddProductMock.defaultExpectation != nil && afterAddProductCounter < 1 {
		if m.AddProductMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartServiceMock.AddProduct at\n%s", m.AddProductMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartServiceMock.AddProduct at\n%s with params: %#v", m.AddProductMock.defaultExpectation.expectationOrigins.origin, *m.AddProductMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddProduct != nil && afterAddProductCounter < 1 {
		m.t.Errorf("Expected call to CartServiceMock.AddProduct at\n%s", m.funcAddProductOrigin)
	}

	if !m.AddProductMock.invocationsDone() && afterAddProductCounter > 0 {
		m.t.Errorf("Expected %d calls to CartServiceMock.AddProduct at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddProductMock.expectedInvocations), m.AddProductMock.expectedInvocationsOrigin, afterAddProductCounter)
	}
}

type mCartServiceMockCart struct {
	optional           bool
	mock               *CartServiceMock
	defaultExpectation *CartServiceMockCartExpectation
	expectations       []*CartServiceMockCartExpectation

	callArgs []*CartServiceMockCartParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartServiceMockCartExpectation specifies expectation struct of the CartService.Cart
type CartServiceMockCartExpectation struct {
	mock               *CartServiceMock
	params             *CartServiceMockCartParams
	paramPtrs          *CartServiceMockCartParamPtrs
	expectationOrigins CartServiceMockCartExpectationOrigins
	results            *CartServiceMockCartResults
	returnOrigin       string
	Counter            uint64
}

// CartServiceMockCartParams contains parameters of the CartService.Cart
type CartServiceMockCartParams struct {
	ctx    context.Context
	userID int64
}

// CartServiceMockCartParamPtrs contains pointers to parameters of the CartService.Cart
type CartServiceMockCartParamPtrs struct {
	ctx    *context.Context
	userID *int64
}

// CartServiceMockCartResults contains results of the CartService.Cart
type CartServiceMockCartResults struct {
	cp1 *models.Cart
	err error
}

// CartServiceMockCartOrigins contains origins of expectations of the CartService.Cart
type CartServiceMockCartExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCart *mCartServiceMockCart) Optional() *mCartServiceMockCart {
	mmCart.optional = true
	return mmCart
}

// Expect sets up expected params for CartService.Cart
func (mmCart *mCartServiceMockCart) Expect(ctx context.Context, userID int64) *mCartServiceMockCart {
	if mmCart.mock.funcCart != nil {
		mmCart.mock.t.Fatalf("CartServiceMock.Cart mock is already set by Set")
	}

	if mmCart.defaultExpectation == nil {
		mmCart.defaultExpectation = &CartServiceMockCartExpectation{}
	}

	if mmCart.defaultExpectation.paramPtrs != nil {
		mmCart.mock.t.Fatalf("CartServiceMock.Cart mock is already set by ExpectParams functions")
	}

	mmCart.defaultExpectation.params = &CartServiceMockCartParams{ctx, userID}
	mmCart.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCart.expectations {
		if minimock.Equal(e.params, mmCart.defaultExpectation.params) {
			mmCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCart.defaultExpectation.params)
		}
	}

	return mmCart
}

// ExpectCtxParam1 sets up expected param ctx for CartService.Cart
func (mmCart *mCartServiceMockCart) ExpectCtxParam1(ctx context.Context) *mCartServiceMockCart {
	if mmCart.mock.funcCart != nil {
		mmCart.mock.t.Fatalf("CartServiceMock.Cart mock is already set by Set")
	}

	if mmCart.defaultExpectation == nil {
		mmCart.defaultExpectation = &CartServiceMockCartExpectation{}
	}

	if mmCart.defaultExpectation.params != nil {
		mmCart.mock.t.Fatalf("CartServiceMock.Cart mock is already set by Expect")
	}

	if mmCart.defaultExpectation.paramPtrs == nil {
		mmCart.defaultExpectation.paramPtrs = &CartServiceMockCartParamPtrs{}
	}
	mmCart.defaultExpectation.paramPtrs.ctx = &ctx
	mmCart.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCart
}

// ExpectUserIDParam2 sets up expected param userID for CartService.Cart
func (mmCart *mCartServiceMockCart) ExpectUserIDParam2(userID int64) *mCartServiceMockCart {
	if mmCart.mock.funcCart != nil {
		mmCart.mock.t.Fatalf("CartServiceMock.Cart mock is already set by Set")
	}

	if mmCart.defaultExpectation == nil {
		mmCart.defaultExpectation = &CartServiceMockCartExpectation{}
	}

	if mmCart.defaultExpectation.params != nil {
		mmCart.mock.t.Fatalf("CartServiceMock.Cart mock is already set by Expect")
	}

	if mmCart.defaultExpectation.paramPtrs == nil {
		mmCart.defaultExpectation.paramPtrs = &CartServiceMockCartParamPtrs{}
	}
	mmCart.defaultExpectation.paramPtrs.userID = &userID
	mmCart.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmCart
}

// Inspect accepts an inspector function that has same arguments as the CartService.Cart
func (mmCart *mCartServiceMockCart) Inspect(f func(ctx context.Context, userID int64)) *mCartServiceMockCart {
	if mmCart.mock.inspectFuncCart != nil {
		mmCart.mock.t.Fatalf("Inspect function is already set for CartServiceMock.Cart")
	}

	mmCart.mock.inspectFuncCart = f

	return mmCart
}

// Return sets up results that will be returned by CartService.Cart
func (mmCart *mCartServiceMockCart) Return(cp1 *models.Cart, err error) *CartServiceMock {
	if mmCart.mock.funcCart != nil {
		mmCart.mock.t.Fatalf("CartServiceMock.Cart mock is already set by Set")
	}

	if mmCart.defaultExpectation == nil {
		mmCart.defaultExpectation = &CartServiceMockCartExpectation{mock: mmCart.mock}
	}
	mmCart.defaultExpectation.results = &CartServiceMockCartResults{cp1, err}
	mmCart.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCart.mock
}

// Set uses given function f to mock the CartService.Cart method
func (mmCart *mCartServiceMockCart) Set(f func(ctx context.Context, userID int64) (cp1 *models.Cart, err error)) *CartServiceMock {
	if mmCart.defaultExpectation != nil {
		mmCart.mock.t.Fatalf("Default expectation is already set for the CartService.Cart method")
	}

	if len(mmCart.expectations) > 0 {
		mmCart.mock.t.Fatalf("Some expectations are already set for the CartService.Cart method")
	}

	mmCart.mock.funcCart = f
	mmCart.mock.funcCartOrigin = minimock.CallerInfo(1)
	return mmCart.mock
}

// When sets expectation for the CartService.Cart which will trigger the result defined by the following
// Then helper
func (mmCart *mCartServiceMockCart) When(ctx context.Context, userID int64) *CartServiceMockCartExpectation {
	if mmCart.mock.funcCart != nil {
		mmCart.mock.t.Fatalf("CartServiceMock.Cart mock is already set by Set")
	}

	expectation := &CartServiceMockCartExpectation{
		mock:               mmCart.mock,
		params:             &CartServiceMockCartParams{ctx, userID},
		expectationOrigins: CartServiceMockCartExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCart.expectations = append(mmCart.expectations, expectation)
	return expectation
}

// Then sets up CartService.Cart return parameters for the expectation previously defined by the When method
func (e *CartServiceMockCartExpectation) Then(cp1 *models.Cart, err error) *CartServiceMock {
	e.results = &CartServiceMockCartResults{cp1, err}
	return e.mock
}

// Times sets number of times CartService.Cart should be invoked
func (mmCart *mCartServiceMockCart) Times(n uint64) *mCartServiceMockCart {
	if n == 0 {
		mmCart.mock.t.Fatalf("Times of CartServiceMock.Cart mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCart.expectedInvocations, n)
	mmCart.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCart
}

func (mmCart *mCartServiceMockCart) invocationsDone() bool {
	if len(mmCart.expectations) == 0 && mmCart.defaultExpectation == nil && mmCart.mock.funcCart == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCart.mock.afterCartCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCart.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Cart implements mm_api.CartService
func (mmCart *CartServiceMock) Cart(ctx context.Context, userID int64) (cp1 *models.Cart, err error) {
	mm_atomic.AddUint64(&mmCart.beforeCartCounter, 1)
	defer mm_atomic.AddUint64(&mmCart.afterCartCounter, 1)

	mmCart.t.Helper()

	if mmCart.inspectFuncCart != nil {
		mmCart.inspectFuncCart(ctx, userID)
	}

	mm_params := CartServiceMockCartParams{ctx, userID}

	// Record call args
	mmCart.CartMock.mutex.Lock()
	mmCart.CartMock.callArgs = append(mmCart.CartMock.callArgs, &mm_params)
	mmCart.CartMock.mutex.Unlock()

	for _, e := range mmCart.CartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmCart.CartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCart.CartMock.defaultExpectation.Counter, 1)
		mm_want := mmCart.CartMock.defaultExpectation.params
		mm_want_ptrs := mmCart.CartMock.defaultExpectation.paramPtrs

		mm_got := CartServiceMockCartParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCart.t.Errorf("CartServiceMock.Cart got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCart.CartMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmCart.t.Errorf("CartServiceMock.Cart got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCart.CartMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCart.t.Errorf("CartServiceMock.Cart got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCart.CartMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCart.CartMock.defaultExpectation.results
		if mm_results == nil {
			mmCart.t.Fatal("No results are set for the CartServiceMock.Cart")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmCart.funcCart != nil {
		return mmCart.funcCart(ctx, userID)
	}
	mmCart.t.Fatalf("Unexpected call to CartServiceMock.Cart. %v %v", ctx, userID)
	return
}

// CartAfterCounter returns a count of finished CartServiceMock.Cart invocations
func (mmCart *CartServiceMock) CartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCart.afterCartCounter)
}

// CartBeforeCounter returns a count of CartServiceMock.Cart invocations
func (mmCart *CartServiceMock) CartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCart.beforeCartCounter)
}

// Calls returns a list of arguments used in each call to CartServiceMock.Cart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCart *mCartServiceMockCart) Calls() []*CartServiceMockCartParams {
	mmCart.mutex.RLock()

	argCopy := make([]*CartServiceMockCartParams, len(mmCart.callArgs))
	copy(argCopy, mmCart.callArgs)

	mmCart.mutex.RUnlock()

	return argCopy
}

// MinimockCartDone returns true if the count of the Cart invocations corresponds
// the number of defined expectations
func (m *CartServiceMock) MinimockCartDone() bool {
	if m.CartMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CartMock.invocationsDone()
}

// MinimockCartInspect logs each unmet expectation
func (m *CartServiceMock) MinimockCartInspect() {
	for _, e := range m.CartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartServiceMock.Cart at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCartCounter := mm_atomic.LoadUint64(&m.afterCartCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CartMock.defaultExpectation != nil && afterCartCounter < 1 {
		if m.CartMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartServiceMock.Cart at\n%s", m.CartMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartServiceMock.Cart at\n%s with params: %#v", m.CartMock.defaultExpectation.expectationOrigins.origin, *m.CartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCart != nil && afterCartCounter < 1 {
		m.t.Errorf("Expected call to CartServiceMock.Cart at\n%s", m.funcCartOrigin)
	}

	if !m.CartMock.invocationsDone() && afterCartCounter > 0 {
		m.t.Errorf("Expected %d calls to CartServiceMock.Cart at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CartMock.expectedInvocations), m.CartMock.expectedInvocationsOrigin, afterCartCounter)
	}
}

type mCartServiceMockCheckout struct {
	optional           bool
	mock               *CartServiceMock
	defaultExpectation *CartServiceMockCheckoutExpectation
	expectations       []*CartServiceMockCheckoutExpectation

	callArgs []*CartServiceMockCheckoutParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartServiceMockCheckoutExpectation specifies expectation struct of the CartService.Checkout
type CartServiceMockCheckoutExpectation struct {
	mock               *CartServiceMock
	params             *CartServiceMockCheckoutParams
	paramPtrs          *CartServiceMockCheckoutParamPtrs
	expectationOrigins CartServiceMockCheckoutExpectationOrigins
	results            *CartServiceMockCheckoutResults
	returnOrigin       string
	Counter            uint64
}

// CartServiceMockCheckoutParams contains parameters of the CartService.Checkout
type CartServiceMockCheckoutParams struct {
	ctx    context.Context
	userID int64
}

// CartServiceMockCheckoutParamPtrs contains pointers to parameters of the CartService.Checkout
type CartServiceMockCheckoutParamPtrs struct {
	ctx    *context.Context
	userID *int64
}

// CartServiceMockCheckoutResults contains results of the CartService.Checkout
type CartServiceMockCheckoutResults struct {
	i1  int64
	err error
}

// CartServiceMockCheckoutOrigins contains origins of expectations of the CartService.Checkout
type CartServiceMockCheckoutExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCheckout *mCartServiceMockCheckout) Optional() *mCartServiceMockCheckout {
	mmCheckout.optional = true
	return mmCheckout
}

// Expect sets up expected params for CartService.Checkout
func (mmCheckout *mCartServiceMockCheckout) Expect(ctx context.Context, userID int64) *mCartServiceMockCheckout {
	if mmCheckout.mock.funcCheckout != nil {
		mmCheckout.mock.t.Fatalf("CartServiceMock.Checkout mock is already set by Set")
	}

	if mmCheckout.defaultExpectation == nil {
		mmCheckout.defaultExpectation = &CartServiceMockCheckoutExpectation{}
	}

	if mmCheckout.defaultExpectation.paramPtrs != nil {
		mmCheckout.mock.t.Fatalf("CartServiceMock.Checkout mock is already set by ExpectParams functions")
	}

	mmCheckout.defaultExpectation.params = &CartServiceMockCheckoutParams{ctx, userID}
	mmCheckout.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCheckout.expectations {
		if minimock.Equal(e.params, mmCheckout.defaultExpectation.params) {
			mmCheckout.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckout.defaultExpectation.params)
		}
	}

	return mmCheckout
}

// ExpectCtxParam1 sets up expected param ctx for CartService.Checkout
func (mmCheckout *mCartServiceMockCheckout) ExpectCtxParam1(ctx context.Context) *mCartServiceMockCheckout {
	if mmCheckout.mock.funcCheckout != nil {
		mmCheckout.mock.t.Fatalf("CartServiceMock.Checkout mock is already set by Set")
	}

	if mmCheckout.defaultExpectation == nil {
		mmCheckout.defaultExpectation = &CartServiceMockCheckoutExpectation{}
	}

	if mmCheckout.defaultExpectation.params != nil {
		mmCheckout.mock.t.Fatalf("CartServiceMock.Checkout mock is already set by Expect")
	}

	if mmCheckout.defaultExpectation.paramPtrs == nil {
		mmCheckout.defaultExpectation.paramPtrs = &CartServiceMockCheckoutParamPtrs{}
	}
	mmCheckout.defaultExpectation.paramPtrs.ctx = &ctx
	mmCheckout.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCheckout
}

// ExpectUserIDParam2 sets up expected param userID for CartService.Checkout
func (mmCheckout *mCartServiceMockCheckout) ExpectUserIDParam2(userID int64) *mCartServiceMockCheckout {
	if mmCheckout.mock.funcCheckout != nil {
		mmCheckout.mock.t.Fatalf("CartServiceMock.Checkout mock is already set by Set")
	}

	if mmCheckout.defaultExpectation == nil {
		mmCheckout.defaultExpectation = &CartServiceMockCheckoutExpectation{}
	}

	if mmCheckout.defaultExpectation.params != nil {
		mmCheckout.mock.t.Fatalf("CartServiceMock.Checkout mock is already set by Expect")
	}

	if mmCheckout.defaultExpectation.paramPtrs == nil {
		mmCheckout.defaultExpectation.paramPtrs = &CartServiceMockCheckoutParamPtrs{}
	}
	mmCheckout.defaultExpectation.paramPtrs.userID = &userID
	mmCheckout.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmCheckout
}

// Inspect accepts an inspector function that has same arguments as the CartService.Checkout
func (mmCheckout *mCartServiceMockCheckout) Inspect(f func(ctx context.Context, userID int64)) *mCartServiceMockCheckout {
	if mmCheckout.mock.inspectFuncCheckout != nil {
		mmCheckout.mock.t.Fatalf("Inspect function is already set for CartServiceMock.Checkout")
	}

	mmCheckout.mock.inspectFuncCheckout = f

	return mmCheckout
}

// Return sets up results that will be returned by CartService.Checkout
func (mmCheckout *mCartServiceMockCheckout) Return(i1 int64, err error) *CartServiceMock {
	if mmCheckout.mock.funcCheckout != nil {
		mmCheckout.mock.t.Fatalf("CartServiceMock.Checkout mock is already set by Set")
	}

	if mmCheckout.defaultExpectation == nil {
		mmCheckout.defaultExpectation = &CartServiceMockCheckoutExpectation{mock: mmCheckout.mock}
	}
	mmCheckout.defaultExpectation.results = &CartServiceMockCheckoutResults{i1, err}
	mmCheckout.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCheckout.mock
}

// Set uses given function f to mock the CartService.Checkout method
func (mmCheckout *mCartServiceMockCheckout) Set(f func(ctx context.Context, userID int64) (i1 int64, err error)) *CartServiceMock {
	if mmCheckout.defaultExpectation != nil {
		mmCheckout.mock.t.Fatalf("Default expectation is already set for the CartService.Checkout method")
	}

	if len(mmCheckout.expectations) > 0 {
		mmCheckout.mock.t.Fatalf("Some expectations are already set for the CartService.Checkout method")
	}

	mmCheckout.mock.funcCheckout = f
	mmCheckout.mock.funcCheckoutOrigin = minimock.CallerInfo(1)
	return mmCheckout.mock
}

// When sets expectation for the CartService.Checkout which will trigger the result defined by the following
// Then helper
func (mmCheckout *mCartServiceMockCheckout) When(ctx context.Context, userID int64) *CartServiceMockCheckoutExpectation {
	if mmCheckout.mock.funcCheckout != nil {
		mmCheckout.mock.t.Fatalf("CartServiceMock.Checkout mock is already set by Set")
	}

	expectation := &CartServiceMockCheckoutExpectation{
		mock:               mmCheckout.mock,
		params:             &CartServiceMockCheckoutParams{ctx, userID},
		expectationOrigins: CartServiceMockCheckoutExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCheckout.expectations = append(mmCheckout.expectations, expectation)
	return expectation
}

// Then sets up CartService.Checkout return parameters for the expectation previously defined by the When method
func (e *CartServiceMockCheckoutExpectation) Then(i1 int64, err error) *CartServiceMock {
	e.results = &CartServiceMockCheckoutResults{i1, err}
	return e.mock
}

// Times sets number of times CartService.Checkout should be invoked
func (mmCheckout *mCartServiceMockCheckout) Times(n uint64) *mCartServiceMockCheckout {
	if n == 0 {
		mmCheckout.mock.t.Fatalf("Times of CartServiceMock.Checkout mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCheckout.expectedInvocations, n)
	mmCheckout.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCheckout
}

func (mmCheckout *mCartServiceMockCheckout) invocationsDone() bool {
	if len(mmCheckout.expectations) == 0 && mmCheckout.defaultExpectation == nil && mmCheckout.mock.funcCheckout == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCheckout.mock.afterCheckoutCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCheckout.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Checkout implements mm_api.CartService
func (mmCheckout *CartServiceMock) Checkout(ctx context.Context, userID int64) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCheckout.beforeCheckoutCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckout.afterCheckoutCounter, 1)

	mmCheckout.t.Helper()

	if mmCheckout.inspectFuncCheckout != nil {
		mmCheckout.inspectFuncCheckout(ctx, userID)
	}

	mm_params := CartServiceMockCheckoutParams{ctx, userID}

	// Record call args
	mmCheckout.CheckoutMock.mutex.Lock()
	mmCheckout.CheckoutMock.callArgs = append(mmCheckout.CheckoutMock.callArgs, &mm_params)
	mmCheckout.CheckoutMock.mutex.Unlock()

	for _, e := range mmCheckout.CheckoutMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCheckout.CheckoutMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckout.CheckoutMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckout.CheckoutMock.defaultExpectation.params
		mm_want_ptrs := mmCheckout.CheckoutMock.defaultExpectation.paramPtrs

		mm_got := CartServiceMockCheckoutParams{ctx, userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCheckout.t.Errorf("CartServiceMock.Checkout got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckout.CheckoutMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmCheckout.t.Errorf("CartServiceMock.Checkout got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheckout.CheckoutMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckout.t.Errorf("CartServiceMock.Checkout got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCheckout.CheckoutMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckout.CheckoutMock.defaultExpectation.results
		if mm_results == nil {
			mmCheckout.t.Fatal("No results are set for the CartServiceMock.Checkout")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCheckout.funcCheckout != nil {
		return mmCheckout.funcCheckout(ctx, userID)
	}
	mmCheckout.t.Fatalf("Unexpected call to CartServiceMock.Checkout. %v %v", ctx, userID)
	return
}

// CheckoutAfterCounter returns a count of finished CartServiceMock.Checkout invocations
func (mmCheckout *CartServiceMock) CheckoutAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckout.afterCheckoutCounter)
}

// CheckoutBeforeCounter returns a count of CartServiceMock.Checkout invocations
func (mmCheckout *CartServiceMock) CheckoutBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckout.beforeCheckoutCounter)
}

// Calls returns a list of arguments used in each call to CartServiceMock.Checkout.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckout *mCartServiceMockCheckout) Calls() []*CartServiceMockCheckoutParams {
	mmCheckout.mutex.RLock()

	argCopy := make([]*CartServiceMockCheckoutParams, len(mmCheckout.callArgs))
	copy(argCopy, mmCheckout.callArgs)

	mmCheckout.mutex.RUnlock()

	return argCopy
}

// MinimockCheckoutDone returns true if the count of the Checkout invocations corresponds
// the number of defined expectations
func (m *CartServiceMock) MinimockCheckoutDone() bool {
	if m.CheckoutMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CheckoutMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CheckoutMock.invocationsDone()
}

// MinimockCheckoutInspect logs each unmet expectation
func (m *CartServiceMock) MinimockCheckoutInspect() {
	for _, e := range m.CheckoutMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartServiceMock.Checkout at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCheckoutCounter := mm_atomic.LoadUint64(&m.afterCheckoutCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CheckoutMock.defaultExpectation != nil && afterCheckoutCounter < 1 {
		if m.CheckoutMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartServiceMock.Checkout at\n%s", m.CheckoutMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartServiceMock.Checkout at\n%s with params: %#v", m.CheckoutMock.defaultExpectation.expectationOrigins.origin, *m.CheckoutMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckout != nil && afterCheckoutCounter < 1 {
		m.t.Errorf("Expected call to CartServiceMock.Checkout at\n%s", m.funcCheckoutOrigin)
	}

	if !m.CheckoutMock.invocationsDone() && afterCheckoutCounter > 0 {
		m.t.Errorf("Expected %d calls to CartServiceMock.Checkout at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CheckoutMock.expectedInvocations), m.CheckoutMock.expectedInvocationsOrigin, afterCheckoutCounter)
	}
}

type mCartServiceMockClearCart struct {
	optional           bool
	mock               *CartServiceMock
	defaultExpectation *CartServiceMockClearCartExpectation
	expectations       []*CartServiceMockClearCartExpectation

	callArgs []*CartServiceMockClearCartParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartServiceMockClearCartExpectation specifies expectation struct of the CartService.ClearCart
type CartServiceMockClearCartExpectation struct {
	mock               *CartServiceMock
	params             *CartServiceMockClearCartParams
	paramPtrs          *CartServiceMockClearCartParamPtrs
	expectationOrigins CartServiceMockClearCartExpectationOrigins
	results            *CartServiceMockClearCartResults
	returnOrigin       string
	Counter            uint64
}

// CartServiceMockClearCartParams contains parameters of the CartService.ClearCart
type CartServiceMockClearCartParams struct {
	userID int64
}

// CartServiceMockClearCartParamPtrs contains pointers to parameters of the CartService.ClearCart
type CartServiceMockClearCartParamPtrs struct {
	userID *int64
}

// CartServiceMockClearCartResults contains results of the CartService.ClearCart
type CartServiceMockClearCartResults struct {
	b1 bool
}

// CartServiceMockClearCartOrigins contains origins of expectations of the CartService.ClearCart
type CartServiceMockClearCartExpectationOrigins struct {
	origin       string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmClearCart *mCartServiceMockClearCart) Optional() *mCartServiceMockClearCart {
	mmClearCart.optional = true
	return mmClearCart
}

// Expect sets up expected params for CartService.ClearCart
func (mmClearCart *mCartServiceMockClearCart) Expect(userID int64) *mCartServiceMockClearCart {
	if mmClearCart.mock.funcClearCart != nil {
		mmClearCart.mock.t.Fatalf("CartServiceMock.ClearCart mock is already set by Set")
	}

	if mmClearCart.defaultExpectation == nil {
		mmClearCart.defaultExpectation = &CartServiceMockClearCartExpectation{}
	}

	if mmClearCart.defaultExpectation.paramPtrs != nil {
		mmClearCart.mock.t.Fatalf("CartServiceMock.ClearCart mock is already set by ExpectParams functions")
	}

	mmClearCart.defaultExpectation.params = &CartServiceMockClearCartParams{userID}
	mmClearCart.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmClearCart.expectations {
		if minimock.Equal(e.params, mmClearCart.defaultExpectation.params) {
			mmClearCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmClearCart.defaultExpectation.params)
		}
	}

	return mmClearCart
}

// ExpectUserIDParam1 sets up expected param userID for CartService.ClearCart
func (mmClearCart *mCartServiceMockClearCart) ExpectUserIDParam1(userID int64) *mCartServiceMockClearCart {
	if mmClearCart.mock.funcClearCart != nil {
		mmClearCart.mock.t.Fatalf("CartServiceMock.ClearCart mock is already set by Set")
	}

	if mmClearCart.defaultExpectation == nil {
		mmClearCart.defaultExpectation = &CartServiceMockClearCartExpectation{}
	}

	if mmClearCart.defaultExpectation.params != nil {
		mmClearCart.mock.t.Fatalf("CartServiceMock.ClearCart mock is already set by Expect")
	}

	if mmClearCart.defaultExpectation.paramPtrs == nil {
		mmClearCart.defaultExpectation.paramPtrs = &CartServiceMockClearCartParamPtrs{}
	}
	mmClearCart.defaultExpectation.paramPtrs.userID = &userID
	mmClearCart.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmClearCart
}

// Inspect accepts an inspector function that has same arguments as the CartService.ClearCart
func (mmClearCart *mCartServiceMockClearCart) Inspect(f func(userID int64)) *mCartServiceMockClearCart {
	if mmClearCart.mock.inspectFuncClearCart != nil {
		mmClearCart.mock.t.Fatalf("Inspect function is already set for CartServiceMock.ClearCart")
	}

	mmClearCart.mock.inspectFuncClearCart = f

	return mmClearCart
}

// Return sets up results that will be returned by CartService.ClearCart
func (mmClearCart *mCartServiceMockClearCart) Return(b1 bool) *CartServiceMock {
	if mmClearCart.mock.funcClearCart != nil {
		mmClearCart.mock.t.Fatalf("CartServiceMock.ClearCart mock is already set by Set")
	}

	if mmClearCart.defaultExpectation == nil {
		mmClearCart.defaultExpectation = &CartServiceMockClearCartExpectation{mock: mmClearCart.mock}
	}
	mmClearCart.defaultExpectation.results = &CartServiceMockClearCartResults{b1}
	mmClearCart.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmClearCart.mock
}

// Set uses given function f to mock the CartService.ClearCart method
func (mmClearCart *mCartServiceMockClearCart) Set(f func(userID int64) (b1 bool)) *CartServiceMock {
	if mmClearCart.defaultExpectation != nil {
		mmClearCart.mock.t.Fatalf("Default expectation is already set for the CartService.ClearCart method")
	}

	if len(mmClearCart.expectations) > 0 {
		mmClearCart.mock.t.Fatalf("Some expectations are already set for the CartService.ClearCart method")
	}

	mmClearCart.mock.funcClearCart = f
	mmClearCart.mock.funcClearCartOrigin = minimock.CallerInfo(1)
	return mmClearCart.mock
}

// When sets expectation for the CartService.ClearCart which will trigger the result defined by the following
// Then helper
func (mmClearCart *mCartServiceMockClearCart) When(userID int64) *CartServiceMockClearCartExpectation {
	if mmClearCart.mock.funcClearCart != nil {
		mmClearCart.mock.t.Fatalf("CartServiceMock.ClearCart mock is already set by Set")
	}

	expectation := &CartServiceMockClearCartExpectation{
		mock:               mmClearCart.mock,
		params:             &CartServiceMockClearCartParams{userID},
		expectationOrigins: CartServiceMockClearCartExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmClearCart.expectations = append(mmClearCart.expectations, expectation)
	return expectation
}

// Then sets up CartService.ClearCart return parameters for the expectation previously defined by the When method
func (e *CartServiceMockClearCartExpectation) Then(b1 bool) *CartServiceMock {
	e.results = &CartServiceMockClearCartResults{b1}
	return e.mock
}

// Times sets number of times CartService.ClearCart should be invoked
func (mmClearCart *mCartServiceMockClearCart) Times(n uint64) *mCartServiceMockClearCart {
	if n == 0 {
		mmClearCart.mock.t.Fatalf("Times of CartServiceMock.ClearCart mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmClearCart.expectedInvocations, n)
	mmClearCart.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmClearCart
}

func (mmClearCart *mCartServiceMockClearCart) invocationsDone() bool {
	if len(mmClearCart.expectations) == 0 && mmClearCart.defaultExpectation == nil && mmClearCart.mock.funcClearCart == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmClearCart.mock.afterClearCartCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmClearCart.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ClearCart implements mm_api.CartService
func (mmClearCart *CartServiceMock) ClearCart(userID int64) (b1 bool) {
	mm_atomic.AddUint64(&mmClearCart.beforeClearCartCounter, 1)
	defer mm_atomic.AddUint64(&mmClearCart.afterClearCartCounter, 1)

	mmClearCart.t.Helper()

	if mmClearCart.inspectFuncClearCart != nil {
		mmClearCart.inspectFuncClearCart(userID)
	}

	mm_params := CartServiceMockClearCartParams{userID}

	// Record call args
	mmClearCart.ClearCartMock.mutex.Lock()
	mmClearCart.ClearCartMock.callArgs = append(mmClearCart.ClearCartMock.callArgs, &mm_params)
	mmClearCart.ClearCartMock.mutex.Unlock()

	for _, e := range mmClearCart.ClearCartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmClearCart.ClearCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClearCart.ClearCartMock.defaultExpectation.Counter, 1)
		mm_want := mmClearCart.ClearCartMock.defaultExpectation.params
		mm_want_ptrs := mmClearCart.ClearCartMock.defaultExpectation.paramPtrs

		mm_got := CartServiceMockClearCartParams{userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmClearCart.t.Errorf("CartServiceMock.ClearCart got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmClearCart.ClearCartMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmClearCart.t.Errorf("CartServiceMock.ClearCart got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmClearCart.ClearCartMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmClearCart.ClearCartMock.defaultExpectation.results
		if mm_results == nil {
			mmClearCart.t.Fatal("No results are set for the CartServiceMock.ClearCart")
		}
		return (*mm_results).b1
	}
	if mmClearCart.funcClearCart != nil {
		return mmClearCart.funcClearCart(userID)
	}
	mmClearCart.t.Fatalf("Unexpected call to CartServiceMock.ClearCart. %v", userID)
	return
}

// ClearCartAfterCounter returns a count of finished CartServiceMock.ClearCart invocations
func (mmClearCart *CartServiceMock) ClearCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClearCart.afterClearCartCounter)
}

// ClearCartBeforeCounter returns a count of CartServiceMock.ClearCart invocations
func (mmClearCart *CartServiceMock) ClearCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClearCart.beforeClearCartCounter)
}

// Calls returns a list of arguments used in each call to CartServiceMock.ClearCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmClearCart *mCartServiceMockClearCart) Calls() []*CartServiceMockClearCartParams {
	mmClearCart.mutex.RLock()

	argCopy := make([]*CartServiceMockClearCartParams, len(mmClearCart.callArgs))
	copy(argCopy, mmClearCart.callArgs)

	mmClearCart.mutex.RUnlock()

	return argCopy
}

// MinimockClearCartDone returns true if the count of the ClearCart invocations corresponds
// the number of defined expectations
func (m *CartServiceMock) MinimockClearCartDone() bool {
	if m.ClearCartMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ClearCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ClearCartMock.invocationsDone()
}

// MinimockClearCartInspect logs each unmet expectation
func (m *CartServiceMock) MinimockClearCartInspect() {
	for _, e := range m.ClearCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartServiceMock.ClearCart at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterClearCartCounter := mm_atomic.LoadUint64(&m.afterClearCartCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ClearCartMock.defaultExpectation != nil && afterClearCartCounter < 1 {
		if m.ClearCartMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartServiceMock.ClearCart at\n%s", m.ClearCartMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartServiceMock.ClearCart at\n%s with params: %#v", m.ClearCartMock.defaultExpectation.expectationOrigins.origin, *m.ClearCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClearCart != nil && afterClearCartCounter < 1 {
		m.t.Errorf("Expected call to CartServiceMock.ClearCart at\n%s", m.funcClearCartOrigin)
	}

	if !m.ClearCartMock.invocationsDone() && afterClearCartCounter > 0 {
		m.t.Errorf("Expected %d calls to CartServiceMock.ClearCart at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ClearCartMock.expectedInvocations), m.ClearCartMock.expectedInvocationsOrigin, afterClearCartCounter)
	}
}

type mCartServiceMockDeleteProduct struct {
	optional           bool
	mock               *CartServiceMock
	defaultExpectation *CartServiceMockDeleteProductExpectation
	expectations       []*CartServiceMockDeleteProductExpectation

	callArgs []*CartServiceMockDeleteProductParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartServiceMockDeleteProductExpectation specifies expectation struct of the CartService.DeleteProduct
type CartServiceMockDeleteProductExpectation struct {
	mock               *CartServiceMock
	params             *CartServiceMockDeleteProductParams
	paramPtrs          *CartServiceMockDeleteProductParamPtrs
	expectationOrigins CartServiceMockDeleteProductExpectationOrigins
	results            *CartServiceMockDeleteProductResults
	returnOrigin       string
	Counter            uint64
}

// CartServiceMockDeleteProductParams contains parameters of the CartService.DeleteProduct
type CartServiceMockDeleteProductParams struct {
	ctx    context.Context
	userID int64
	sku    int64
}

// CartServiceMockDeleteProductParamPtrs contains pointers to parameters of the CartService.DeleteProduct
type CartServiceMockDeleteProductParamPtrs struct {
	ctx    *context.Context
	userID *int64
	sku    *int64
}

// CartServiceMockDeleteProductResults contains results of the CartService.DeleteProduct
type CartServiceMockDeleteProductResults struct {
	err error
}

// CartServiceMockDeleteProductOrigins contains origins of expectations of the CartService.DeleteProduct
type CartServiceMockDeleteProductExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
	originSku    string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteProduct *mCartServiceMockDeleteProduct) Optional() *mCartServiceMockDeleteProduct {
	mmDeleteProduct.optional = true
	return mmDeleteProduct
}

// Expect sets up expected params for CartService.DeleteProduct
func (mmDeleteProduct *mCartServiceMockDeleteProduct) Expect(ctx context.Context, userID int64, sku int64) *mCartServiceMockDeleteProduct {
	if mmDeleteProduct.mock.funcDeleteProduct != nil {
		mmDeleteProduct.mock.t.Fatalf("CartServiceMock.DeleteProduct mock is already set by Set")
	}

	if mmDeleteProduct.defaultExpectation == nil {
		mmDeleteProduct.defaultExpectation = &CartServiceMockDeleteProductExpectation{}
	}

	if mmDeleteProduct.defaultExpectation.paramPtrs != nil {
		mmDeleteProduct.mock.t.Fatalf("CartServiceMock.DeleteProduct mock is already set by ExpectParams functions")
	}

	mmDeleteProduct.defaultExpectation.params = &CartServiceMockDeleteProductParams{ctx, userID, sku}
	mmDeleteProduct.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteProduct.expectations {
		if minimock.Equal(e.params, mmDeleteProduct.defaultExpectation.params) {
			mmDeleteProduct.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteProduct.defaultExpectation.params)
		}
	}

	return mmDeleteProduct
}

// ExpectCtxParam1 sets up expected param ctx for CartService.DeleteProduct
func (mmDeleteProduct *mCartServiceMockDeleteProduct) ExpectCtxParam1(ctx context.Context) *mCartServiceMockDeleteProduct {
	if mmDeleteProduct.mock.funcDeleteProduct != nil {
		mmDeleteProduct.mock.t.Fatalf("CartServiceMock.DeleteProduct mock is already set by Set")
	}

	if mmDeleteProduct.defaultExpectation == nil {
		mmDeleteProduct.defaultExpectation = &CartServiceMockDeleteProductExpectation{}
	}

	if mmDeleteProduct.defaultExpectation.params != nil {
		mmDeleteProduct.mock.t.Fatalf("CartServiceMock.DeleteProduct mock is already set by Expect")
	}

	if mmDeleteProduct.defaultExpectation.paramPtrs == nil {
		mmDeleteProduct.defaultExpectation.paramPtrs = &CartServiceMockDeleteProductParamPtrs{}
	}
	mmDeleteProduct.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteProduct.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteProduct
}

// ExpectUserIDParam2 sets up expected param userID for CartService.DeleteProduct
func (mmDeleteProduct *mCartServiceMockDeleteProduct) ExpectUserIDParam2(userID int64) *mCartServiceMockDeleteProduct {
	if mmDeleteProduct.mock.funcDeleteProduct != nil {
		mmDeleteProduct.mock.t.Fatalf("CartServiceMock.DeleteProduct mock is already set by Set")
	}

	if mmDeleteProduct.defaultExpectation == nil {
		mmDeleteProduct.defaultExpectation = &CartServiceMockDeleteProductExpectation{}
	}

	if mmDeleteProduct.defaultExpectation.params != nil {
		mmDeleteProduct.mock.t.Fatalf("CartServiceMock.DeleteProduct mock is already set by Expect")
	}

	if mmDeleteProduct.defaultExpectation.paramPtrs == nil {
		mmDeleteProduct.defaultExpectation.paramPtrs = &CartServiceMockDeleteProductParamPtrs{}
	}
	mmDeleteProduct.defaultExpectation.paramPtrs.userID = &userID
	mmDeleteProduct.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmDeleteProduct
}

// ExpectSkuParam3 sets up expected param sku for CartService.DeleteProduct
func (mmDeleteProduct *mCartServiceMockDeleteProduct) ExpectSkuParam3(sku int64) *mCartServiceMockDeleteProduct {
	if mmDeleteProduct.mock.funcDeleteProduct != nil {
		mmDeleteProduct.mock.t.Fatalf("CartServiceMock.DeleteProduct mock is already set by Set")
	}

	if mmDeleteProduct.defaultExpectation == nil {
		mmDeleteProduct.defaultExpectation = &CartServiceMockDeleteProductExpectation{}
	}

	if mmDeleteProduct.defaultExpectation.params != nil {
		mmDeleteProduct.mock.t.Fatalf("CartServiceMock.DeleteProduct mock is already set by Expect")
	}

	if mmDeleteProduct.defaultExpectation.paramPtrs == nil {
		mmDeleteProduct.defaultExpectation.paramPtrs = &CartServiceMockDeleteProductParamPtrs{}
	}
	mmDeleteProduct.defaultExpectation.paramPtrs.sku = &sku
	mmDeleteProduct.defaultExpectation.expectationOrigins.originSku = minimock.CallerInfo(1)

	return mmDeleteProduct
}

// Inspect accepts an inspector function that has same arguments as the CartService.DeleteProduct
func (mmDeleteProduct *mCartServiceMockDeleteProduct) Inspect(f func(ctx context.Context, userID int64, sku int64)) *mCartServiceMockDeleteProduct {
	if mmDeleteProduct.mock.inspectFuncDeleteProduct != nil {
		mmDeleteProduct.mock.t.Fatalf("Inspect function is already set for CartServiceMock.DeleteProduct")
	}

	mmDeleteProduct.mock.inspectFuncDeleteProduct = f

	return mmDeleteProduct
}

// Return sets up results that will be returned by CartService.DeleteProduct
func (mmDeleteProduct *mCartServiceMockDeleteProduct) Return(err error) *CartServiceMock {
	if mmDeleteProduct.mock.funcDeleteProduct != nil {
		mmDeleteProduct.mock.t.Fatalf("CartServiceMock.DeleteProduct mock is already set by Set")
	}

	if mmDeleteProduct.defaultExpectation == nil {
		mmDeleteProduct.defaultExpectation = &CartServiceMockDeleteProductExpectation{mock: mmDeleteProduct.mock}
	}
	mmDeleteProduct.defaultExpectation.results = &CartServiceMockDeleteProductResults{err}
	mmDeleteProduct.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteProduct.mock
}

// Set uses given function f to mock the CartService.DeleteProduct method
func (mmDeleteProduct *mCartServiceMockDeleteProduct) Set(f func(ctx context.Context, userID int64, sku int64) (err error)) *CartServiceMock {
	if mmDeleteProduct.defaultExpectation != nil {
		mmDeleteProduct.mock.t.Fatalf("Default expectation is already set for the CartService.DeleteProduct method")
	}

	if len(mmDeleteProduct.expectations) > 0 {
		mmDeleteProduct.mock.t.Fatalf("Some expectations are already set for the CartService.DeleteProduct method")
	}

	mmDeleteProduct.mock.funcDeleteProduct = f
	mmDeleteProduct.mock.funcDeleteProductOrigin = minimock.CallerInfo(1)
	return mmDeleteProduct.mock
}

// When sets expectation for the CartService.DeleteProduct which will trigger the result defined by the following
// Then helper
func (mmDeleteProduct *mCartServiceMockDeleteProduct) When(ctx context.Context, userID int64, sku int64) *CartServiceMockDeleteProductExpectation {
	if mmDeleteProduct.mock.funcDeleteProduct != nil {
		mmDeleteProduct.mock.t.Fatalf("CartServiceMock.DeleteProduct mock is already set by Set")
	}

	expectation := &CartServiceMockDeleteProductExpectation{
		mock:               mmDeleteProduct.mock,
		params:             &CartServiceMockDeleteProductParams{ctx, userID, sku},
		expectationOrigins: CartServiceMockDeleteProductExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteProduct.expectations = append(mmDeleteProduct.expectations, expectation)
	return expectation
}

// Then sets up CartService.DeleteProduct return parameters for the expectation previously defined by the When method
func (e *CartServiceMockDeleteProductExpectation) Then(err error) *CartServiceMock {
	e.results = &CartServiceMockDeleteProductResults{err}
	return e.mock
}

// Times sets number of times CartService.DeleteProduct should be invoked
func (mmDeleteProduct *mCartServiceMockDeleteProduct) Times(n uint64) *mCartServiceMockDeleteProduct {
	if n == 0 {
		mmDeleteProduct.mock.t.Fatalf("Times of CartServiceMock.DeleteProduct mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteProduct.expectedInvocations, n)
	mmDeleteProduct.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteProduct
}

func (mmDeleteProduct *mCartServiceMockDeleteProduct) invocationsDone() bool {
	if len(mmDeleteProduct.expectations) == 0 && mmDeleteProduct.defaultExpectation == nil && mmDeleteProduct.mock.funcDeleteProduct == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteProduct.mock.afterDeleteProductCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteProduct.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteProduct implements mm_api.CartService
func (mmDeleteProduct *CartServiceMock) DeleteProduct(ctx context.Context, userID int64, sku int64) (err error) {
	mm_atomic.AddUint64(&mmDeleteProduct.beforeDeleteProductCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteProduct.afterDeleteProductCounter, 1)

	mmDeleteProduct.t.Helper()

	if mmDeleteProduct.inspectFuncDeleteProduct != nil {
		mmDeleteProduct.inspectFuncDeleteProduct(ctx, userID, sku)
	}

	mm_params := CartServiceMockDeleteProductParams{ctx, userID, sku}

	// Record call args
	mmDeleteProduct.DeleteProductMock.mutex.Lock()
	mmDeleteProduct.DeleteProductMock.callArgs = append(mmDeleteProduct.DeleteProductMock.callArgs, &mm_params)
	mmDeleteProduct.DeleteProductMock.mutex.Unlock()

	for _, e := range mmDeleteProduct.DeleteProductMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteProduct.DeleteProductMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteProduct.DeleteProductMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteProduct.DeleteProductMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteProduct.DeleteProductMock.defaultExpectation.paramPtrs

		mm_got := CartServiceMockDeleteProductParams{ctx, userID, sku}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteProduct.t.Errorf("CartServiceMock.DeleteProduct got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteProduct.DeleteProductMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmDeleteProduct.t.Errorf("CartServiceMock.DeleteProduct got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteProduct.DeleteProductMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.sku != nil && !minimock.Equal(*mm_want_ptrs.sku, mm_got.sku) {
				mmDeleteProduct.t.Errorf("CartServiceMock.DeleteProduct got unexpected parameter sku, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteProduct.DeleteProductMock.defaultExpectation.expectationOrigins.originSku, *mm_want_ptrs.sku, mm_got.sku, minimock.Diff(*mm_want_ptrs.sku, mm_got.sku))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteProduct.t.Errorf("CartServiceMock.DeleteProduct got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteProduct.DeleteProductMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteProduct.DeleteProductMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteProduct.t.Fatal("No results are set for the CartServiceMock.DeleteProduct")
		}
		return (*mm_results).err
	}
	if mmDeleteProduct.funcDeleteProduct != nil {
		return mmDeleteProduct.funcDeleteProduct(ctx, userID, sku)
	}
	mmDeleteProduct.t.Fatalf("Unexpected call to CartServiceMock.DeleteProduct. %v %v %v", ctx, userID, sku)
	return
}

// DeleteProductAfterCounter returns a count of finished CartServiceMock.DeleteProduct invocations
func (mmDeleteProduct *CartServiceMock) DeleteProductAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteProduct.afterDeleteProductCounter)
}

// DeleteProductBeforeCounter returns a count of CartServiceMock.DeleteProduct invocations
func (mmDeleteProduct *CartServiceMock) DeleteProductBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteProduct.beforeDeleteProductCounter)
}

// Calls returns a list of arguments used in each call to CartServiceMock.DeleteProduct.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteProduct *mCartServiceMockDeleteProduct) Calls() []*CartServiceMockDeleteProductParams {
	mmDeleteProduct.mutex.RLock()

	argCopy := make([]*CartServiceMockDeleteProductParams, len(mmDeleteProduct.callArgs))
	copy(argCopy, mmDeleteProduct.callArgs)

	mmDeleteProduct.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteProductDone returns true if the count of the DeleteProduct invocations corresponds
// the number of defined expectations
func (m *CartServiceMock) MinimockDeleteProductDone() bool {
	if m.DeleteProductMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteProductMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteProductMock.invocationsDone()
}

// MinimockDeleteProductInspect logs each unmet expectation
func (m *CartServiceMock) MinimockDeleteProductInspect() {
	for _, e := range m.DeleteProductMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartServiceMock.DeleteProduct at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteProductCounter := mm_atomic.LoadUint64(&m.afterDeleteProductCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteProductMock.defaultExpectation != nil && afterDeleteProductCounter < 1 {
		if m.DeleteProductMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartServiceMock.DeleteProduct at\n%s", m.DeleteProductMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartServiceMock.DeleteProduct at\n%s with params: %#v", m.DeleteProductMock.defaultExpectation.expectationOrigins.origin, *m.DeleteProductMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteProduct != nil && afterDeleteProductCounter < 1 {
		m.t.Errorf("Expected call to CartServiceMock.DeleteProduct at\n%s", m.funcDeleteProductOrigin)
	}

	if !m.DeleteProductMock.invocationsDone() && afterDeleteProductCounter > 0 {
		m.t.Errorf("Expected %d calls to CartServiceMock.DeleteProduct at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteProductMock.expectedInvocations), m.DeleteProductMock.expectedInvocationsOrigin, afterDeleteProductCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CartServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddProductInspect()

			m.MinimockCartInspect()

			m.MinimockCheckoutInspect()

			m.MinimockClearCartInspect()

			m.MinimockDeleteProductInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CartServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CartServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddProductDone() &&
		m.MinimockCartDone() &&
		m.MinimockCheckoutDone() &&
		m.MinimockClearCartDone() &&
		m.MinimockDeleteProductDone()
}
