// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocked

//go:generate minimock -i route256/cart/internal/service.Repository -o repository_mock.go -n RepositoryMock -p mocked

import (
	"route256/cart/internal/models"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// RepositoryMock implements mm_service.Repository
type RepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddProduct          func(userID int64, product *models.Product, count uint32)
	funcAddProductOrigin    string
	inspectFuncAddProduct   func(userID int64, product *models.Product, count uint32)
	afterAddProductCounter  uint64
	beforeAddProductCounter uint64
	AddProductMock          mRepositoryMockAddProduct

	funcCart          func(userID int64) (p1 models.Products)
	funcCartOrigin    string
	inspectFuncCart   func(userID int64)
	afterCartCounter  uint64
	beforeCartCounter uint64
	CartMock          mRepositoryMockCart

	funcClear          func(userID int64) (b1 bool)
	funcClearOrigin    string
	inspectFuncClear   func(userID int64)
	afterClearCounter  uint64
	beforeClearCounter uint64
	ClearMock          mRepositoryMockClear

	funcDeleteProduct          func(userID int64, product *models.Product)
	funcDeleteProductOrigin    string
	inspectFuncDeleteProduct   func(userID int64, product *models.Product)
	afterDeleteProductCounter  uint64
	beforeDeleteProductCounter uint64
	DeleteProductMock          mRepositoryMockDeleteProduct
}

// NewRepositoryMock returns a mock for mm_service.Repository
func NewRepositoryMock(t minimock.Tester) *RepositoryMock {
	m := &RepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddProductMock = mRepositoryMockAddProduct{mock: m}
	m.AddProductMock.callArgs = []*RepositoryMockAddProductParams{}

	m.CartMock = mRepositoryMockCart{mock: m}
	m.CartMock.callArgs = []*RepositoryMockCartParams{}

	m.ClearMock = mRepositoryMockClear{mock: m}
	m.ClearMock.callArgs = []*RepositoryMockClearParams{}

	m.DeleteProductMock = mRepositoryMockDeleteProduct{mock: m}
	m.DeleteProductMock.callArgs = []*RepositoryMockDeleteProductParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRepositoryMockAddProduct struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockAddProductExpectation
	expectations       []*RepositoryMockAddProductExpectation

	callArgs []*RepositoryMockAddProductParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockAddProductExpectation specifies expectation struct of the Repository.AddProduct
type RepositoryMockAddProductExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockAddProductParams
	paramPtrs          *RepositoryMockAddProductParamPtrs
	expectationOrigins RepositoryMockAddProductExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// RepositoryMockAddProductParams contains parameters of the Repository.AddProduct
type RepositoryMockAddProductParams struct {
	userID  int64
	product *models.Product
	count   uint32
}

// RepositoryMockAddProductParamPtrs contains pointers to parameters of the Repository.AddProduct
type RepositoryMockAddProductParamPtrs struct {
	userID  *int64
	product **models.Product
	count   *uint32
}

// RepositoryMockAddProductOrigins contains origins of expectations of the Repository.AddProduct
type RepositoryMockAddProductExpectationOrigins struct {
	origin        string
	originUserID  string
	originProduct string
	originCount   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddProduct *mRepositoryMockAddProduct) Optional() *mRepositoryMockAddProduct {
	mmAddProduct.optional = true
	return mmAddProduct
}

// Expect sets up expected params for Repository.AddProduct
func (mmAddProduct *mRepositoryMockAddProduct) Expect(userID int64, product *models.Product, count uint32) *mRepositoryMockAddProduct {
	if mmAddProduct.mock.funcAddProduct != nil {
		mmAddProduct.mock.t.Fatalf("RepositoryMock.AddProduct mock is already set by Set")
	}

	if mmAddProduct.defaultExpectation == nil {
		mmAddProduct.defaultExpectation = &RepositoryMockAddProductExpectation{}
	}

	if mmAddProduct.defaultExpectation.paramPtrs != nil {
		mmAddProduct.mock.t.Fatalf("RepositoryMock.AddProduct mock is already set by ExpectParams functions")
	}

	mmAddProduct.defaultExpectation.params = &RepositoryMockAddProductParams{userID, product, count}
	mmAddProduct.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddProduct.expectations {
		if minimock.Equal(e.params, mmAddProduct.defaultExpectation.params) {
			mmAddProduct.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddProduct.defaultExpectation.params)
		}
	}

	return mmAddProduct
}

// ExpectUserIDParam1 sets up expected param userID for Repository.AddProduct
func (mmAddProduct *mRepositoryMockAddProduct) ExpectUserIDParam1(userID int64) *mRepositoryMockAddProduct {
	if mmAddProduct.mock.funcAddProduct != nil {
		mmAddProduct.mock.t.Fatalf("RepositoryMock.AddProduct mock is already set by Set")
	}

	if mmAddProduct.defaultExpectation == nil {
		mmAddProduct.defaultExpectation = &RepositoryMockAddProductExpectation{}
	}

	if mmAddProduct.defaultExpectation.params != nil {
		mmAddProduct.mock.t.Fatalf("RepositoryMock.AddProduct mock is already set by Expect")
	}

	if mmAddProduct.defaultExpectation.paramPtrs == nil {
		mmAddProduct.defaultExpectation.paramPtrs = &RepositoryMockAddProductParamPtrs{}
	}
	mmAddProduct.defaultExpectation.paramPtrs.userID = &userID
	mmAddProduct.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmAddProduct
}

// ExpectProductParam2 sets up expected param product for Repository.AddProduct
func (mmAddProduct *mRepositoryMockAddProduct) ExpectProductParam2(product *models.Product) *mRepositoryMockAddProduct {
	if mmAddProduct.mock.funcAddProduct != nil {
		mmAddProduct.mock.t.Fatalf("RepositoryMock.AddProduct mock is already set by Set")
	}

	if mmAddProduct.defaultExpectation == nil {
		mmAddProduct.defaultExpectation = &RepositoryMockAddProductExpectation{}
	}

	if mmAddProduct.defaultExpectation.params != nil {
		mmAddProduct.mock.t.Fatalf("RepositoryMock.AddProduct mock is already set by Expect")
	}

	if mmAddProduct.defaultExpectation.paramPtrs == nil {
		mmAddProduct.defaultExpectation.paramPtrs = &RepositoryMockAddProductParamPtrs{}
	}
	mmAddProduct.defaultExpectation.paramPtrs.product = &product
	mmAddProduct.defaultExpectation.expectationOrigins.originProduct = minimock.CallerInfo(1)

	return mmAddProduct
}

// ExpectCountParam3 sets up expected param count for Repository.AddProduct
func (mmAddProduct *mRepositoryMockAddProduct) ExpectCountParam3(count uint32) *mRepositoryMockAddProduct {
	if mmAddProduct.mock.funcAddProduct != nil {
		mmAddProduct.mock.t.Fatalf("RepositoryMock.AddProduct mock is already set by Set")
	}

	if mmAddProduct.defaultExpectation == nil {
		mmAddProduct.defaultExpectation = &RepositoryMockAddProductExpectation{}
	}

	if mmAddProduct.defaultExpectation.params != nil {
		mmAddProduct.mock.t.Fatalf("RepositoryMock.AddProduct mock is already set by Expect")
	}

	if mmAddProduct.defaultExpectation.paramPtrs == nil {
		mmAddProduct.defaultExpectation.paramPtrs = &RepositoryMockAddProductParamPtrs{}
	}
	mmAddProduct.defaultExpectation.paramPtrs.count = &count
	mmAddProduct.defaultExpectation.expectationOrigins.originCount = minimock.CallerInfo(1)

	return mmAddProduct
}

// Inspect accepts an inspector function that has same arguments as the Repository.AddProduct
func (mmAddProduct *mRepositoryMockAddProduct) Inspect(f func(userID int64, product *models.Product, count uint32)) *mRepositoryMockAddProduct {
	if mmAddProduct.mock.inspectFuncAddProduct != nil {
		mmAddProduct.mock.t.Fatalf("Inspect function is already set for RepositoryMock.AddProduct")
	}

	mmAddProduct.mock.inspectFuncAddProduct = f

	return mmAddProduct
}

// Return sets up results that will be returned by Repository.AddProduct
func (mmAddProduct *mRepositoryMockAddProduct) Return() *RepositoryMock {
	if mmAddProduct.mock.funcAddProduct != nil {
		mmAddProduct.mock.t.Fatalf("RepositoryMock.AddProduct mock is already set by Set")
	}

	if mmAddProduct.defaultExpectation == nil {
		mmAddProduct.defaultExpectation = &RepositoryMockAddProductExpectation{mock: mmAddProduct.mock}
	}

	mmAddProduct.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddProduct.mock
}

// Set uses given function f to mock the Repository.AddProduct method
func (mmAddProduct *mRepositoryMockAddProduct) Set(f func(userID int64, product *models.Product, count uint32)) *RepositoryMock {
	if mmAddProduct.defaultExpectation != nil {
		mmAddProduct.mock.t.Fatalf("Default expectation is already set for the Repository.AddProduct method")
	}

	if len(mmAddProduct.expectations) > 0 {
		mmAddProduct.mock.t.Fatalf("Some expectations are already set for the Repository.AddProduct method")
	}

	mmAddProduct.mock.funcAddProduct = f
	mmAddProduct.mock.funcAddProductOrigin = minimock.CallerInfo(1)
	return mmAddProduct.mock
}

// When sets expectation for the Repository.AddProduct which will trigger the result defined by the following
// Then helper
func (mmAddProduct *mRepositoryMockAddProduct) When(userID int64, product *models.Product, count uint32) *RepositoryMockAddProductExpectation {
	if mmAddProduct.mock.funcAddProduct != nil {
		mmAddProduct.mock.t.Fatalf("RepositoryMock.AddProduct mock is already set by Set")
	}

	expectation := &RepositoryMockAddProductExpectation{
		mock:               mmAddProduct.mock,
		params:             &RepositoryMockAddProductParams{userID, product, count},
		expectationOrigins: RepositoryMockAddProductExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddProduct.expectations = append(mmAddProduct.expectations, expectation)
	return expectation
}

// Then sets up Repository.AddProduct return parameters for the expectation previously defined by the When method

func (e *RepositoryMockAddProductExpectation) Then() *RepositoryMock {
	return e.mock
}

// Times sets number of times Repository.AddProduct should be invoked
func (mmAddProduct *mRepositoryMockAddProduct) Times(n uint64) *mRepositoryMockAddProduct {
	if n == 0 {
		mmAddProduct.mock.t.Fatalf("Times of RepositoryMock.AddProduct mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddProduct.expectedInvocations, n)
	mmAddProduct.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddProduct
}

func (mmAddProduct *mRepositoryMockAddProduct) invocationsDone() bool {
	if len(mmAddProduct.expectations) == 0 && mmAddProduct.defaultExpectation == nil && mmAddProduct.mock.funcAddProduct == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddProduct.mock.afterAddProductCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddProduct.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddProduct implements mm_service.Repository
func (mmAddProduct *RepositoryMock) AddProduct(userID int64, product *models.Product, count uint32) {
	mm_atomic.AddUint64(&mmAddProduct.beforeAddProductCounter, 1)
	defer mm_atomic.AddUint64(&mmAddProduct.afterAddProductCounter, 1)

	mmAddProduct.t.Helper()

	if mmAddProduct.inspectFuncAddProduct != nil {
		mmAddProduct.inspectFuncAddProduct(userID, product, count)
	}

	mm_params := RepositoryMockAddProductParams{userID, product, count}

	// Record call args
	mmAddProduct.AddProductMock.mutex.Lock()
	mmAddProduct.AddProductMock.callArgs = append(mmAddProduct.AddProductMock.callArgs, &mm_params)
	mmAddProduct.AddProductMock.mutex.Unlock()

	for _, e := range mmAddProduct.AddProductMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAddProduct.AddProductMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddProduct.AddProductMock.defaultExpectation.Counter, 1)
		mm_want := mmAddProduct.AddProductMock.defaultExpectation.params
		mm_want_ptrs := mmAddProduct.AddProductMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockAddProductParams{userID, product, count}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmAddProduct.t.Errorf("RepositoryMock.AddProduct got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddProduct.AddProductMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.product != nil && !minimock.Equal(*mm_want_ptrs.product, mm_got.product) {
				mmAddProduct.t.Errorf("RepositoryMock.AddProduct got unexpected parameter product, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddProduct.AddProductMock.defaultExpectation.expectationOrigins.originProduct, *mm_want_ptrs.product, mm_got.product, minimock.Diff(*mm_want_ptrs.product, mm_got.product))
			}

			if mm_want_ptrs.count != nil && !minimock.Equal(*mm_want_ptrs.count, mm_got.count) {
				mmAddProduct.t.Errorf("RepositoryMock.AddProduct got unexpected parameter count, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddProduct.AddProductMock.defaultExpectation.expectationOrigins.originCount, *mm_want_ptrs.count, mm_got.count, minimock.Diff(*mm_want_ptrs.count, mm_got.count))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddProduct.t.Errorf("RepositoryMock.AddProduct got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddProduct.AddProductMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmAddProduct.funcAddProduct != nil {
		mmAddProduct.funcAddProduct(userID, product, count)
		return
	}
	mmAddProduct.t.Fatalf("Unexpected call to RepositoryMock.AddProduct. %v %v %v", userID, product, count)

}

// AddProductAfterCounter returns a count of finished RepositoryMock.AddProduct invocations
func (mmAddProduct *RepositoryMock) AddProductAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddProduct.afterAddProductCounter)
}

// AddProductBeforeCounter returns a count of RepositoryMock.AddProduct invocations
func (mmAddProduct *RepositoryMock) AddProductBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddProduct.beforeAddProductCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.AddProduct.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddProduct *mRepositoryMockAddProduct) Calls() []*RepositoryMockAddProductParams {
	mmAddProduct.mutex.RLock()

	argCopy := make([]*RepositoryMockAddProductParams, len(mmAddProduct.callArgs))
	copy(argCopy, mmAddProduct.callArgs)

	mmAddProduct.mutex.RUnlock()

	return argCopy
}

// MinimockAddProductDone returns true if the count of the AddProduct invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockAddProductDone() bool {
	if m.AddProductMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddProductMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddProductMock.invocationsDone()
}

// MinimockAddProductInspect logs each unmet expectation
func (m *RepositoryMock) MinimockAddProductInspect() {
	for _, e := range m.AddProductMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.AddProduct at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddProductCounter := mm_atomic.LoadUint64(&m.afterAddProductCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddProductMock.defaultExpectation != nil && afterAddProductCounter < 1 {
		if m.AddProductMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.AddProduct at\n%s", m.AddProductMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.AddProduct at\n%s with params: %#v", m.AddProductMock.defaultExpectation.expectationOrigins.origin, *m.AddProductMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddProduct != nil && afterAddProductCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.AddProduct at\n%s", m.funcAddProductOrigin)
	}

	if !m.AddProductMock.invocationsDone() && afterAddProductCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.AddProduct at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddProductMock.expectedInvocations), m.AddProductMock.expectedInvocationsOrigin, afterAddProductCounter)
	}
}

type mRepositoryMockCart struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCartExpectation
	expectations       []*RepositoryMockCartExpectation

	callArgs []*RepositoryMockCartParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockCartExpectation specifies expectation struct of the Repository.Cart
type RepositoryMockCartExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockCartParams
	paramPtrs          *RepositoryMockCartParamPtrs
	expectationOrigins RepositoryMockCartExpectationOrigins
	results            *RepositoryMockCartResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockCartParams contains parameters of the Repository.Cart
type RepositoryMockCartParams struct {
	userID int64
}

// RepositoryMockCartParamPtrs contains pointers to parameters of the Repository.Cart
type RepositoryMockCartParamPtrs struct {
	userID *int64
}

// RepositoryMockCartResults contains results of the Repository.Cart
type RepositoryMockCartResults struct {
	p1 models.Products
}

// RepositoryMockCartOrigins contains origins of expectations of the Repository.Cart
type RepositoryMockCartExpectationOrigins struct {
	origin       string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCart *mRepositoryMockCart) Optional() *mRepositoryMockCart {
	mmCart.optional = true
	return mmCart
}

// Expect sets up expected params for Repository.Cart
func (mmCart *mRepositoryMockCart) Expect(userID int64) *mRepositoryMockCart {
	if mmCart.mock.funcCart != nil {
		mmCart.mock.t.Fatalf("RepositoryMock.Cart mock is already set by Set")
	}

	if mmCart.defaultExpectation == nil {
		mmCart.defaultExpectation = &RepositoryMockCartExpectation{}
	}

	if mmCart.defaultExpectation.paramPtrs != nil {
		mmCart.mock.t.Fatalf("RepositoryMock.Cart mock is already set by ExpectParams functions")
	}

	mmCart.defaultExpectation.params = &RepositoryMockCartParams{userID}
	mmCart.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCart.expectations {
		if minimock.Equal(e.params, mmCart.defaultExpectation.params) {
			mmCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCart.defaultExpectation.params)
		}
	}

	return mmCart
}

// ExpectUserIDParam1 sets up expected param userID for Repository.Cart
func (mmCart *mRepositoryMockCart) ExpectUserIDParam1(userID int64) *mRepositoryMockCart {
	if mmCart.mock.funcCart != nil {
		mmCart.mock.t.Fatalf("RepositoryMock.Cart mock is already set by Set")
	}

	if mmCart.defaultExpectation == nil {
		mmCart.defaultExpectation = &RepositoryMockCartExpectation{}
	}

	if mmCart.defaultExpectation.params != nil {
		mmCart.mock.t.Fatalf("RepositoryMock.Cart mock is already set by Expect")
	}

	if mmCart.defaultExpectation.paramPtrs == nil {
		mmCart.defaultExpectation.paramPtrs = &RepositoryMockCartParamPtrs{}
	}
	mmCart.defaultExpectation.paramPtrs.userID = &userID
	mmCart.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmCart
}

// Inspect accepts an inspector function that has same arguments as the Repository.Cart
func (mmCart *mRepositoryMockCart) Inspect(f func(userID int64)) *mRepositoryMockCart {
	if mmCart.mock.inspectFuncCart != nil {
		mmCart.mock.t.Fatalf("Inspect function is already set for RepositoryMock.Cart")
	}

	mmCart.mock.inspectFuncCart = f

	return mmCart
}

// Return sets up results that will be returned by Repository.Cart
func (mmCart *mRepositoryMockCart) Return(p1 models.Products) *RepositoryMock {
	if mmCart.mock.funcCart != nil {
		mmCart.mock.t.Fatalf("RepositoryMock.Cart mock is already set by Set")
	}

	if mmCart.defaultExpectation == nil {
		mmCart.defaultExpectation = &RepositoryMockCartExpectation{mock: mmCart.mock}
	}
	mmCart.defaultExpectation.results = &RepositoryMockCartResults{p1}
	mmCart.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCart.mock
}

// Set uses given function f to mock the Repository.Cart method
func (mmCart *mRepositoryMockCart) Set(f func(userID int64) (p1 models.Products)) *RepositoryMock {
	if mmCart.defaultExpectation != nil {
		mmCart.mock.t.Fatalf("Default expectation is already set for the Repository.Cart method")
	}

	if len(mmCart.expectations) > 0 {
		mmCart.mock.t.Fatalf("Some expectations are already set for the Repository.Cart method")
	}

	mmCart.mock.funcCart = f
	mmCart.mock.funcCartOrigin = minimock.CallerInfo(1)
	return mmCart.mock
}

// When sets expectation for the Repository.Cart which will trigger the result defined by the following
// Then helper
func (mmCart *mRepositoryMockCart) When(userID int64) *RepositoryMockCartExpectation {
	if mmCart.mock.funcCart != nil {
		mmCart.mock.t.Fatalf("RepositoryMock.Cart mock is already set by Set")
	}

	expectation := &RepositoryMockCartExpectation{
		mock:               mmCart.mock,
		params:             &RepositoryMockCartParams{userID},
		expectationOrigins: RepositoryMockCartExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCart.expectations = append(mmCart.expectations, expectation)
	return expectation
}

// Then sets up Repository.Cart return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCartExpectation) Then(p1 models.Products) *RepositoryMock {
	e.results = &RepositoryMockCartResults{p1}
	return e.mock
}

// Times sets number of times Repository.Cart should be invoked
func (mmCart *mRepositoryMockCart) Times(n uint64) *mRepositoryMockCart {
	if n == 0 {
		mmCart.mock.t.Fatalf("Times of RepositoryMock.Cart mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCart.expectedInvocations, n)
	mmCart.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCart
}

func (mmCart *mRepositoryMockCart) invocationsDone() bool {
	if len(mmCart.expectations) == 0 && mmCart.defaultExpectation == nil && mmCart.mock.funcCart == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCart.mock.afterCartCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCart.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Cart implements mm_service.Repository
func (mmCart *RepositoryMock) Cart(userID int64) (p1 models.Products) {
	mm_atomic.AddUint64(&mmCart.beforeCartCounter, 1)
	defer mm_atomic.AddUint64(&mmCart.afterCartCounter, 1)

	mmCart.t.Helper()

	if mmCart.inspectFuncCart != nil {
		mmCart.inspectFuncCart(userID)
	}

	mm_params := RepositoryMockCartParams{userID}

	// Record call args
	mmCart.CartMock.mutex.Lock()
	mmCart.CartMock.callArgs = append(mmCart.CartMock.callArgs, &mm_params)
	mmCart.CartMock.mutex.Unlock()

	for _, e := range mmCart.CartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1
		}
	}

	if mmCart.CartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCart.CartMock.defaultExpectation.Counter, 1)
		mm_want := mmCart.CartMock.defaultExpectation.params
		mm_want_ptrs := mmCart.CartMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockCartParams{userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmCart.t.Errorf("RepositoryMock.Cart got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCart.CartMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCart.t.Errorf("RepositoryMock.Cart got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCart.CartMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCart.CartMock.defaultExpectation.results
		if mm_results == nil {
			mmCart.t.Fatal("No results are set for the RepositoryMock.Cart")
		}
		return (*mm_results).p1
	}
	if mmCart.funcCart != nil {
		return mmCart.funcCart(userID)
	}
	mmCart.t.Fatalf("Unexpected call to RepositoryMock.Cart. %v", userID)
	return
}

// CartAfterCounter returns a count of finished RepositoryMock.Cart invocations
func (mmCart *RepositoryMock) CartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCart.afterCartCounter)
}

// CartBeforeCounter returns a count of RepositoryMock.Cart invocations
func (mmCart *RepositoryMock) CartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCart.beforeCartCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.Cart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCart *mRepositoryMockCart) Calls() []*RepositoryMockCartParams {
	mmCart.mutex.RLock()

	argCopy := make([]*RepositoryMockCartParams, len(mmCart.callArgs))
	copy(argCopy, mmCart.callArgs)

	mmCart.mutex.RUnlock()

	return argCopy
}

// MinimockCartDone returns true if the count of the Cart invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCartDone() bool {
	if m.CartMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CartMock.invocationsDone()
}

// MinimockCartInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCartInspect() {
	for _, e := range m.CartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.Cart at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCartCounter := mm_atomic.LoadUint64(&m.afterCartCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CartMock.defaultExpectation != nil && afterCartCounter < 1 {
		if m.CartMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.Cart at\n%s", m.CartMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.Cart at\n%s with params: %#v", m.CartMock.defaultExpectation.expectationOrigins.origin, *m.CartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCart != nil && afterCartCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.Cart at\n%s", m.funcCartOrigin)
	}

	if !m.CartMock.invocationsDone() && afterCartCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.Cart at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CartMock.expectedInvocations), m.CartMock.expectedInvocationsOrigin, afterCartCounter)
	}
}

type mRepositoryMockClear struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockClearExpectation
	expectations       []*RepositoryMockClearExpectation

	callArgs []*RepositoryMockClearParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockClearExpectation specifies expectation struct of the Repository.Clear
type RepositoryMockClearExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockClearParams
	paramPtrs          *RepositoryMockClearParamPtrs
	expectationOrigins RepositoryMockClearExpectationOrigins
	results            *RepositoryMockClearResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockClearParams contains parameters of the Repository.Clear
type RepositoryMockClearParams struct {
	userID int64
}

// RepositoryMockClearParamPtrs contains pointers to parameters of the Repository.Clear
type RepositoryMockClearParamPtrs struct {
	userID *int64
}

// RepositoryMockClearResults contains results of the Repository.Clear
type RepositoryMockClearResults struct {
	b1 bool
}

// RepositoryMockClearOrigins contains origins of expectations of the Repository.Clear
type RepositoryMockClearExpectationOrigins struct {
	origin       string
	originUserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmClear *mRepositoryMockClear) Optional() *mRepositoryMockClear {
	mmClear.optional = true
	return mmClear
}

// Expect sets up expected params for Repository.Clear
func (mmClear *mRepositoryMockClear) Expect(userID int64) *mRepositoryMockClear {
	if mmClear.mock.funcClear != nil {
		mmClear.mock.t.Fatalf("RepositoryMock.Clear mock is already set by Set")
	}

	if mmClear.defaultExpectation == nil {
		mmClear.defaultExpectation = &RepositoryMockClearExpectation{}
	}

	if mmClear.defaultExpectation.paramPtrs != nil {
		mmClear.mock.t.Fatalf("RepositoryMock.Clear mock is already set by ExpectParams functions")
	}

	mmClear.defaultExpectation.params = &RepositoryMockClearParams{userID}
	mmClear.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmClear.expectations {
		if minimock.Equal(e.params, mmClear.defaultExpectation.params) {
			mmClear.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmClear.defaultExpectation.params)
		}
	}

	return mmClear
}

// ExpectUserIDParam1 sets up expected param userID for Repository.Clear
func (mmClear *mRepositoryMockClear) ExpectUserIDParam1(userID int64) *mRepositoryMockClear {
	if mmClear.mock.funcClear != nil {
		mmClear.mock.t.Fatalf("RepositoryMock.Clear mock is already set by Set")
	}

	if mmClear.defaultExpectation == nil {
		mmClear.defaultExpectation = &RepositoryMockClearExpectation{}
	}

	if mmClear.defaultExpectation.params != nil {
		mmClear.mock.t.Fatalf("RepositoryMock.Clear mock is already set by Expect")
	}

	if mmClear.defaultExpectation.paramPtrs == nil {
		mmClear.defaultExpectation.paramPtrs = &RepositoryMockClearParamPtrs{}
	}
	mmClear.defaultExpectation.paramPtrs.userID = &userID
	mmClear.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmClear
}

// Inspect accepts an inspector function that has same arguments as the Repository.Clear
func (mmClear *mRepositoryMockClear) Inspect(f func(userID int64)) *mRepositoryMockClear {
	if mmClear.mock.inspectFuncClear != nil {
		mmClear.mock.t.Fatalf("Inspect function is already set for RepositoryMock.Clear")
	}

	mmClear.mock.inspectFuncClear = f

	return mmClear
}

// Return sets up results that will be returned by Repository.Clear
func (mmClear *mRepositoryMockClear) Return(b1 bool) *RepositoryMock {
	if mmClear.mock.funcClear != nil {
		mmClear.mock.t.Fatalf("RepositoryMock.Clear mock is already set by Set")
	}

	if mmClear.defaultExpectation == nil {
		mmClear.defaultExpectation = &RepositoryMockClearExpectation{mock: mmClear.mock}
	}
	mmClear.defaultExpectation.results = &RepositoryMockClearResults{b1}
	mmClear.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmClear.mock
}

// Set uses given function f to mock the Repository.Clear method
func (mmClear *mRepositoryMockClear) Set(f func(userID int64) (b1 bool)) *RepositoryMock {
	if mmClear.defaultExpectation != nil {
		mmClear.mock.t.Fatalf("Default expectation is already set for the Repository.Clear method")
	}

	if len(mmClear.expectations) > 0 {
		mmClear.mock.t.Fatalf("Some expectations are already set for the Repository.Clear method")
	}

	mmClear.mock.funcClear = f
	mmClear.mock.funcClearOrigin = minimock.CallerInfo(1)
	return mmClear.mock
}

// When sets expectation for the Repository.Clear which will trigger the result defined by the following
// Then helper
func (mmClear *mRepositoryMockClear) When(userID int64) *RepositoryMockClearExpectation {
	if mmClear.mock.funcClear != nil {
		mmClear.mock.t.Fatalf("RepositoryMock.Clear mock is already set by Set")
	}

	expectation := &RepositoryMockClearExpectation{
		mock:               mmClear.mock,
		params:             &RepositoryMockClearParams{userID},
		expectationOrigins: RepositoryMockClearExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmClear.expectations = append(mmClear.expectations, expectation)
	return expectation
}

// Then sets up Repository.Clear return parameters for the expectation previously defined by the When method
func (e *RepositoryMockClearExpectation) Then(b1 bool) *RepositoryMock {
	e.results = &RepositoryMockClearResults{b1}
	return e.mock
}

// Times sets number of times Repository.Clear should be invoked
func (mmClear *mRepositoryMockClear) Times(n uint64) *mRepositoryMockClear {
	if n == 0 {
		mmClear.mock.t.Fatalf("Times of RepositoryMock.Clear mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmClear.expectedInvocations, n)
	mmClear.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmClear
}

func (mmClear *mRepositoryMockClear) invocationsDone() bool {
	if len(mmClear.expectations) == 0 && mmClear.defaultExpectation == nil && mmClear.mock.funcClear == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmClear.mock.afterClearCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmClear.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Clear implements mm_service.Repository
func (mmClear *RepositoryMock) Clear(userID int64) (b1 bool) {
	mm_atomic.AddUint64(&mmClear.beforeClearCounter, 1)
	defer mm_atomic.AddUint64(&mmClear.afterClearCounter, 1)

	mmClear.t.Helper()

	if mmClear.inspectFuncClear != nil {
		mmClear.inspectFuncClear(userID)
	}

	mm_params := RepositoryMockClearParams{userID}

	// Record call args
	mmClear.ClearMock.mutex.Lock()
	mmClear.ClearMock.callArgs = append(mmClear.ClearMock.callArgs, &mm_params)
	mmClear.ClearMock.mutex.Unlock()

	for _, e := range mmClear.ClearMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmClear.ClearMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClear.ClearMock.defaultExpectation.Counter, 1)
		mm_want := mmClear.ClearMock.defaultExpectation.params
		mm_want_ptrs := mmClear.ClearMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockClearParams{userID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmClear.t.Errorf("RepositoryMock.Clear got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmClear.ClearMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmClear.t.Errorf("RepositoryMock.Clear got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmClear.ClearMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmClear.ClearMock.defaultExpectation.results
		if mm_results == nil {
			mmClear.t.Fatal("No results are set for the RepositoryMock.Clear")
		}
		return (*mm_results).b1
	}
	if mmClear.funcClear != nil {
		return mmClear.funcClear(userID)
	}
	mmClear.t.Fatalf("Unexpected call to RepositoryMock.Clear. %v", userID)
	return
}

// ClearAfterCounter returns a count of finished RepositoryMock.Clear invocations
func (mmClear *RepositoryMock) ClearAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClear.afterClearCounter)
}

// ClearBeforeCounter returns a count of RepositoryMock.Clear invocations
func (mmClear *RepositoryMock) ClearBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClear.beforeClearCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.Clear.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmClear *mRepositoryMockClear) Calls() []*RepositoryMockClearParams {
	mmClear.mutex.RLock()

	argCopy := make([]*RepositoryMockClearParams, len(mmClear.callArgs))
	copy(argCopy, mmClear.callArgs)

	mmClear.mutex.RUnlock()

	return argCopy
}

// MinimockClearDone returns true if the count of the Clear invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockClearDone() bool {
	if m.ClearMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ClearMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ClearMock.invocationsDone()
}

// MinimockClearInspect logs each unmet expectation
func (m *RepositoryMock) MinimockClearInspect() {
	for _, e := range m.ClearMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.Clear at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterClearCounter := mm_atomic.LoadUint64(&m.afterClearCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ClearMock.defaultExpectation != nil && afterClearCounter < 1 {
		if m.ClearMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.Clear at\n%s", m.ClearMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.Clear at\n%s with params: %#v", m.ClearMock.defaultExpectation.expectationOrigins.origin, *m.ClearMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClear != nil && afterClearCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.Clear at\n%s", m.funcClearOrigin)
	}

	if !m.ClearMock.invocationsDone() && afterClearCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.Clear at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ClearMock.expectedInvocations), m.ClearMock.expectedInvocationsOrigin, afterClearCounter)
	}
}

type mRepositoryMockDeleteProduct struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteProductExpectation
	expectations       []*RepositoryMockDeleteProductExpectation

	callArgs []*RepositoryMockDeleteProductParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockDeleteProductExpectation specifies expectation struct of the Repository.DeleteProduct
type RepositoryMockDeleteProductExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockDeleteProductParams
	paramPtrs          *RepositoryMockDeleteProductParamPtrs
	expectationOrigins RepositoryMockDeleteProductExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// RepositoryMockDeleteProductParams contains parameters of the Repository.DeleteProduct
type RepositoryMockDeleteProductParams struct {
	userID  int64
	product *models.Product
}

// RepositoryMockDeleteProductParamPtrs contains pointers to parameters of the Repository.DeleteProduct
type RepositoryMockDeleteProductParamPtrs struct {
	userID  *int64
	product **models.Product
}

// RepositoryMockDeleteProductOrigins contains origins of expectations of the Repository.DeleteProduct
type RepositoryMockDeleteProductExpectationOrigins struct {
	origin        string
	originUserID  string
	originProduct string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteProduct *mRepositoryMockDeleteProduct) Optional() *mRepositoryMockDeleteProduct {
	mmDeleteProduct.optional = true
	return mmDeleteProduct
}

// Expect sets up expected params for Repository.DeleteProduct
func (mmDeleteProduct *mRepositoryMockDeleteProduct) Expect(userID int64, product *models.Product) *mRepositoryMockDeleteProduct {
	if mmDeleteProduct.mock.funcDeleteProduct != nil {
		mmDeleteProduct.mock.t.Fatalf("RepositoryMock.DeleteProduct mock is already set by Set")
	}

	if mmDeleteProduct.defaultExpectation == nil {
		mmDeleteProduct.defaultExpectation = &RepositoryMockDeleteProductExpectation{}
	}

	if mmDeleteProduct.defaultExpectation.paramPtrs != nil {
		mmDeleteProduct.mock.t.Fatalf("RepositoryMock.DeleteProduct mock is already set by ExpectParams functions")
	}

	mmDeleteProduct.defaultExpectation.params = &RepositoryMockDeleteProductParams{userID, product}
	mmDeleteProduct.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteProduct.expectations {
		if minimock.Equal(e.params, mmDeleteProduct.defaultExpectation.params) {
			mmDeleteProduct.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteProduct.defaultExpectation.params)
		}
	}

	return mmDeleteProduct
}

// ExpectUserIDParam1 sets up expected param userID for Repository.DeleteProduct
func (mmDeleteProduct *mRepositoryMockDeleteProduct) ExpectUserIDParam1(userID int64) *mRepositoryMockDeleteProduct {
	if mmDeleteProduct.mock.funcDeleteProduct != nil {
		mmDeleteProduct.mock.t.Fatalf("RepositoryMock.DeleteProduct mock is already set by Set")
	}

	if mmDeleteProduct.defaultExpectation == nil {
		mmDeleteProduct.defaultExpectation = &RepositoryMockDeleteProductExpectation{}
	}

	if mmDeleteProduct.defaultExpectation.params != nil {
		mmDeleteProduct.mock.t.Fatalf("RepositoryMock.DeleteProduct mock is already set by Expect")
	}

	if mmDeleteProduct.defaultExpectation.paramPtrs == nil {
		mmDeleteProduct.defaultExpectation.paramPtrs = &RepositoryMockDeleteProductParamPtrs{}
	}
	mmDeleteProduct.defaultExpectation.paramPtrs.userID = &userID
	mmDeleteProduct.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmDeleteProduct
}

// ExpectProductParam2 sets up expected param product for Repository.DeleteProduct
func (mmDeleteProduct *mRepositoryMockDeleteProduct) ExpectProductParam2(product *models.Product) *mRepositoryMockDeleteProduct {
	if mmDeleteProduct.mock.funcDeleteProduct != nil {
		mmDeleteProduct.mock.t.Fatalf("RepositoryMock.DeleteProduct mock is already set by Set")
	}

	if mmDeleteProduct.defaultExpectation == nil {
		mmDeleteProduct.defaultExpectation = &RepositoryMockDeleteProductExpectation{}
	}

	if mmDeleteProduct.defaultExpectation.params != nil {
		mmDeleteProduct.mock.t.Fatalf("RepositoryMock.DeleteProduct mock is already set by Expect")
	}

	if mmDeleteProduct.defaultExpectation.paramPtrs == nil {
		mmDeleteProduct.defaultExpectation.paramPtrs = &RepositoryMockDeleteProductParamPtrs{}
	}
	mmDeleteProduct.defaultExpectation.paramPtrs.product = &product
	mmDeleteProduct.defaultExpectation.expectationOrigins.originProduct = minimock.CallerInfo(1)

	return mmDeleteProduct
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteProduct
func (mmDeleteProduct *mRepositoryMockDeleteProduct) Inspect(f func(userID int64, product *models.Product)) *mRepositoryMockDeleteProduct {
	if mmDeleteProduct.mock.inspectFuncDeleteProduct != nil {
		mmDeleteProduct.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteProduct")
	}

	mmDeleteProduct.mock.inspectFuncDeleteProduct = f

	return mmDeleteProduct
}

// Return sets up results that will be returned by Repository.DeleteProduct
func (mmDeleteProduct *mRepositoryMockDeleteProduct) Return() *RepositoryMock {
	if mmDeleteProduct.mock.funcDeleteProduct != nil {
		mmDeleteProduct.mock.t.Fatalf("RepositoryMock.DeleteProduct mock is already set by Set")
	}

	if mmDeleteProduct.defaultExpectation == nil {
		mmDeleteProduct.defaultExpectation = &RepositoryMockDeleteProductExpectation{mock: mmDeleteProduct.mock}
	}

	mmDeleteProduct.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteProduct.mock
}

// Set uses given function f to mock the Repository.DeleteProduct method
func (mmDeleteProduct *mRepositoryMockDeleteProduct) Set(f func(userID int64, product *models.Product)) *RepositoryMock {
	if mmDeleteProduct.defaultExpectation != nil {
		mmDeleteProduct.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteProduct method")
	}

	if len(mmDeleteProduct.expectations) > 0 {
		mmDeleteProduct.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteProduct method")
	}

	mmDeleteProduct.mock.funcDeleteProduct = f
	mmDeleteProduct.mock.funcDeleteProductOrigin = minimock.CallerInfo(1)
	return mmDeleteProduct.mock
}

// When sets expectation for the Repository.DeleteProduct which will trigger the result defined by the following
// Then helper
func (mmDeleteProduct *mRepositoryMockDeleteProduct) When(userID int64, product *models.Product) *RepositoryMockDeleteProductExpectation {
	if mmDeleteProduct.mock.funcDeleteProduct != nil {
		mmDeleteProduct.mock.t.Fatalf("RepositoryMock.DeleteProduct mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteProductExpectation{
		mock:               mmDeleteProduct.mock,
		params:             &RepositoryMockDeleteProductParams{userID, product},
		expectationOrigins: RepositoryMockDeleteProductExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteProduct.expectations = append(mmDeleteProduct.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteProduct return parameters for the expectation previously defined by the When method

func (e *RepositoryMockDeleteProductExpectation) Then() *RepositoryMock {
	return e.mock
}

// Times sets number of times Repository.DeleteProduct should be invoked
func (mmDeleteProduct *mRepositoryMockDeleteProduct) Times(n uint64) *mRepositoryMockDeleteProduct {
	if n == 0 {
		mmDeleteProduct.mock.t.Fatalf("Times of RepositoryMock.DeleteProduct mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteProduct.expectedInvocations, n)
	mmDeleteProduct.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteProduct
}

func (mmDeleteProduct *mRepositoryMockDeleteProduct) invocationsDone() bool {
	if len(mmDeleteProduct.expectations) == 0 && mmDeleteProduct.defaultExpectation == nil && mmDeleteProduct.mock.funcDeleteProduct == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteProduct.mock.afterDeleteProductCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteProduct.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteProduct implements mm_service.Repository
func (mmDeleteProduct *RepositoryMock) DeleteProduct(userID int64, product *models.Product) {
	mm_atomic.AddUint64(&mmDeleteProduct.beforeDeleteProductCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteProduct.afterDeleteProductCounter, 1)

	mmDeleteProduct.t.Helper()

	if mmDeleteProduct.inspectFuncDeleteProduct != nil {
		mmDeleteProduct.inspectFuncDeleteProduct(userID, product)
	}

	mm_params := RepositoryMockDeleteProductParams{userID, product}

	// Record call args
	mmDeleteProduct.DeleteProductMock.mutex.Lock()
	mmDeleteProduct.DeleteProductMock.callArgs = append(mmDeleteProduct.DeleteProductMock.callArgs, &mm_params)
	mmDeleteProduct.DeleteProductMock.mutex.Unlock()

	for _, e := range mmDeleteProduct.DeleteProductMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmDeleteProduct.DeleteProductMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteProduct.DeleteProductMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteProduct.DeleteProductMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteProduct.DeleteProductMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockDeleteProductParams{userID, product}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmDeleteProduct.t.Errorf("RepositoryMock.DeleteProduct got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteProduct.DeleteProductMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.product != nil && !minimock.Equal(*mm_want_ptrs.product, mm_got.product) {
				mmDeleteProduct.t.Errorf("RepositoryMock.DeleteProduct got unexpected parameter product, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteProduct.DeleteProductMock.defaultExpectation.expectationOrigins.originProduct, *mm_want_ptrs.product, mm_got.product, minimock.Diff(*mm_want_ptrs.product, mm_got.product))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteProduct.t.Errorf("RepositoryMock.DeleteProduct got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteProduct.DeleteProductMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmDeleteProduct.funcDeleteProduct != nil {
		mmDeleteProduct.funcDeleteProduct(userID, product)
		return
	}
	mmDeleteProduct.t.Fatalf("Unexpected call to RepositoryMock.DeleteProduct. %v %v", userID, product)

}

// DeleteProductAfterCounter returns a count of finished RepositoryMock.DeleteProduct invocations
func (mmDeleteProduct *RepositoryMock) DeleteProductAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteProduct.afterDeleteProductCounter)
}

// DeleteProductBeforeCounter returns a count of RepositoryMock.DeleteProduct invocations
func (mmDeleteProduct *RepositoryMock) DeleteProductBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteProduct.beforeDeleteProductCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteProduct.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteProduct *mRepositoryMockDeleteProduct) Calls() []*RepositoryMockDeleteProductParams {
	mmDeleteProduct.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteProductParams, len(mmDeleteProduct.callArgs))
	copy(argCopy, mmDeleteProduct.callArgs)

	mmDeleteProduct.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteProductDone returns true if the count of the DeleteProduct invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteProductDone() bool {
	if m.DeleteProductMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteProductMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteProductMock.invocationsDone()
}

// MinimockDeleteProductInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteProductInspect() {
	for _, e := range m.DeleteProductMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteProduct at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteProductCounter := mm_atomic.LoadUint64(&m.afterDeleteProductCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteProductMock.defaultExpectation != nil && afterDeleteProductCounter < 1 {
		if m.DeleteProductMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.DeleteProduct at\n%s", m.DeleteProductMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteProduct at\n%s with params: %#v", m.DeleteProductMock.defaultExpectation.expectationOrigins.origin, *m.DeleteProductMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteProduct != nil && afterDeleteProductCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.DeleteProduct at\n%s", m.funcDeleteProductOrigin)
	}

	if !m.DeleteProductMock.invocationsDone() && afterDeleteProductCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.DeleteProduct at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteProductMock.expectedInvocations), m.DeleteProductMock.expectedInvocationsOrigin, afterDeleteProductCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddProductInspect()

			m.MinimockCartInspect()

			m.MinimockClearInspect()

			m.MinimockDeleteProductInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddProductDone() &&
		m.MinimockCartDone() &&
		m.MinimockClearDone() &&
		m.MinimockDeleteProductDone()
}
