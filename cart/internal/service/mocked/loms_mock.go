// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocked

//go:generate minimock -i route256/cart/internal/service.Loms -o loms_mock.go -n LomsMock -p mocked

import (
	"context"
	loms "route256/cart/pkg/loms/api/v1"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// LomsMock implements mm_service.Loms
type LomsMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateOrder          func(ctx context.Context, items []*loms.Item) (i1 int64, err error)
	funcCreateOrderOrigin    string
	inspectFuncCreateOrder   func(ctx context.Context, items []*loms.Item)
	afterCreateOrderCounter  uint64
	beforeCreateOrderCounter uint64
	CreateOrderMock          mLomsMockCreateOrder

	funcIsProductAvailable          func(ctx context.Context, sku int64, count uint32) (b1 bool, err error)
	funcIsProductAvailableOrigin    string
	inspectFuncIsProductAvailable   func(ctx context.Context, sku int64, count uint32)
	afterIsProductAvailableCounter  uint64
	beforeIsProductAvailableCounter uint64
	IsProductAvailableMock          mLomsMockIsProductAvailable
}

// NewLomsMock returns a mock for mm_service.Loms
func NewLomsMock(t minimock.Tester) *LomsMock {
	m := &LomsMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateOrderMock = mLomsMockCreateOrder{mock: m}
	m.CreateOrderMock.callArgs = []*LomsMockCreateOrderParams{}

	m.IsProductAvailableMock = mLomsMockIsProductAvailable{mock: m}
	m.IsProductAvailableMock.callArgs = []*LomsMockIsProductAvailableParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mLomsMockCreateOrder struct {
	optional           bool
	mock               *LomsMock
	defaultExpectation *LomsMockCreateOrderExpectation
	expectations       []*LomsMockCreateOrderExpectation

	callArgs []*LomsMockCreateOrderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LomsMockCreateOrderExpectation specifies expectation struct of the Loms.CreateOrder
type LomsMockCreateOrderExpectation struct {
	mock               *LomsMock
	params             *LomsMockCreateOrderParams
	paramPtrs          *LomsMockCreateOrderParamPtrs
	expectationOrigins LomsMockCreateOrderExpectationOrigins
	results            *LomsMockCreateOrderResults
	returnOrigin       string
	Counter            uint64
}

// LomsMockCreateOrderParams contains parameters of the Loms.CreateOrder
type LomsMockCreateOrderParams struct {
	ctx   context.Context
	items []*loms.Item
}

// LomsMockCreateOrderParamPtrs contains pointers to parameters of the Loms.CreateOrder
type LomsMockCreateOrderParamPtrs struct {
	ctx   *context.Context
	items *[]*loms.Item
}

// LomsMockCreateOrderResults contains results of the Loms.CreateOrder
type LomsMockCreateOrderResults struct {
	i1  int64
	err error
}

// LomsMockCreateOrderOrigins contains origins of expectations of the Loms.CreateOrder
type LomsMockCreateOrderExpectationOrigins struct {
	origin      string
	originCtx   string
	originItems string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateOrder *mLomsMockCreateOrder) Optional() *mLomsMockCreateOrder {
	mmCreateOrder.optional = true
	return mmCreateOrder
}

// Expect sets up expected params for Loms.CreateOrder
func (mmCreateOrder *mLomsMockCreateOrder) Expect(ctx context.Context, items []*loms.Item) *mLomsMockCreateOrder {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("LomsMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &LomsMockCreateOrderExpectation{}
	}

	if mmCreateOrder.defaultExpectation.paramPtrs != nil {
		mmCreateOrder.mock.t.Fatalf("LomsMock.CreateOrder mock is already set by ExpectParams functions")
	}

	mmCreateOrder.defaultExpectation.params = &LomsMockCreateOrderParams{ctx, items}
	mmCreateOrder.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateOrder.expectations {
		if minimock.Equal(e.params, mmCreateOrder.defaultExpectation.params) {
			mmCreateOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateOrder.defaultExpectation.params)
		}
	}

	return mmCreateOrder
}

// ExpectCtxParam1 sets up expected param ctx for Loms.CreateOrder
func (mmCreateOrder *mLomsMockCreateOrder) ExpectCtxParam1(ctx context.Context) *mLomsMockCreateOrder {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("LomsMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &LomsMockCreateOrderExpectation{}
	}

	if mmCreateOrder.defaultExpectation.params != nil {
		mmCreateOrder.mock.t.Fatalf("LomsMock.CreateOrder mock is already set by Expect")
	}

	if mmCreateOrder.defaultExpectation.paramPtrs == nil {
		mmCreateOrder.defaultExpectation.paramPtrs = &LomsMockCreateOrderParamPtrs{}
	}
	mmCreateOrder.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateOrder.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateOrder
}

// ExpectItemsParam2 sets up expected param items for Loms.CreateOrder
func (mmCreateOrder *mLomsMockCreateOrder) ExpectItemsParam2(items []*loms.Item) *mLomsMockCreateOrder {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("LomsMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &LomsMockCreateOrderExpectation{}
	}

	if mmCreateOrder.defaultExpectation.params != nil {
		mmCreateOrder.mock.t.Fatalf("LomsMock.CreateOrder mock is already set by Expect")
	}

	if mmCreateOrder.defaultExpectation.paramPtrs == nil {
		mmCreateOrder.defaultExpectation.paramPtrs = &LomsMockCreateOrderParamPtrs{}
	}
	mmCreateOrder.defaultExpectation.paramPtrs.items = &items
	mmCreateOrder.defaultExpectation.expectationOrigins.originItems = minimock.CallerInfo(1)

	return mmCreateOrder
}

// Inspect accepts an inspector function that has same arguments as the Loms.CreateOrder
func (mmCreateOrder *mLomsMockCreateOrder) Inspect(f func(ctx context.Context, items []*loms.Item)) *mLomsMockCreateOrder {
	if mmCreateOrder.mock.inspectFuncCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("Inspect function is already set for LomsMock.CreateOrder")
	}

	mmCreateOrder.mock.inspectFuncCreateOrder = f

	return mmCreateOrder
}

// Return sets up results that will be returned by Loms.CreateOrder
func (mmCreateOrder *mLomsMockCreateOrder) Return(i1 int64, err error) *LomsMock {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("LomsMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &LomsMockCreateOrderExpectation{mock: mmCreateOrder.mock}
	}
	mmCreateOrder.defaultExpectation.results = &LomsMockCreateOrderResults{i1, err}
	mmCreateOrder.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateOrder.mock
}

// Set uses given function f to mock the Loms.CreateOrder method
func (mmCreateOrder *mLomsMockCreateOrder) Set(f func(ctx context.Context, items []*loms.Item) (i1 int64, err error)) *LomsMock {
	if mmCreateOrder.defaultExpectation != nil {
		mmCreateOrder.mock.t.Fatalf("Default expectation is already set for the Loms.CreateOrder method")
	}

	if len(mmCreateOrder.expectations) > 0 {
		mmCreateOrder.mock.t.Fatalf("Some expectations are already set for the Loms.CreateOrder method")
	}

	mmCreateOrder.mock.funcCreateOrder = f
	mmCreateOrder.mock.funcCreateOrderOrigin = minimock.CallerInfo(1)
	return mmCreateOrder.mock
}

// When sets expectation for the Loms.CreateOrder which will trigger the result defined by the following
// Then helper
func (mmCreateOrder *mLomsMockCreateOrder) When(ctx context.Context, items []*loms.Item) *LomsMockCreateOrderExpectation {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("LomsMock.CreateOrder mock is already set by Set")
	}

	expectation := &LomsMockCreateOrderExpectation{
		mock:               mmCreateOrder.mock,
		params:             &LomsMockCreateOrderParams{ctx, items},
		expectationOrigins: LomsMockCreateOrderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateOrder.expectations = append(mmCreateOrder.expectations, expectation)
	return expectation
}

// Then sets up Loms.CreateOrder return parameters for the expectation previously defined by the When method
func (e *LomsMockCreateOrderExpectation) Then(i1 int64, err error) *LomsMock {
	e.results = &LomsMockCreateOrderResults{i1, err}
	return e.mock
}

// Times sets number of times Loms.CreateOrder should be invoked
func (mmCreateOrder *mLomsMockCreateOrder) Times(n uint64) *mLomsMockCreateOrder {
	if n == 0 {
		mmCreateOrder.mock.t.Fatalf("Times of LomsMock.CreateOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateOrder.expectedInvocations, n)
	mmCreateOrder.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateOrder
}

func (mmCreateOrder *mLomsMockCreateOrder) invocationsDone() bool {
	if len(mmCreateOrder.expectations) == 0 && mmCreateOrder.defaultExpectation == nil && mmCreateOrder.mock.funcCreateOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateOrder.mock.afterCreateOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateOrder implements mm_service.Loms
func (mmCreateOrder *LomsMock) CreateOrder(ctx context.Context, items []*loms.Item) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreateOrder.beforeCreateOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateOrder.afterCreateOrderCounter, 1)

	mmCreateOrder.t.Helper()

	if mmCreateOrder.inspectFuncCreateOrder != nil {
		mmCreateOrder.inspectFuncCreateOrder(ctx, items)
	}

	mm_params := LomsMockCreateOrderParams{ctx, items}

	// Record call args
	mmCreateOrder.CreateOrderMock.mutex.Lock()
	mmCreateOrder.CreateOrderMock.callArgs = append(mmCreateOrder.CreateOrderMock.callArgs, &mm_params)
	mmCreateOrder.CreateOrderMock.mutex.Unlock()

	for _, e := range mmCreateOrder.CreateOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateOrder.CreateOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateOrder.CreateOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateOrder.CreateOrderMock.defaultExpectation.params
		mm_want_ptrs := mmCreateOrder.CreateOrderMock.defaultExpectation.paramPtrs

		mm_got := LomsMockCreateOrderParams{ctx, items}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateOrder.t.Errorf("LomsMock.CreateOrder got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateOrder.CreateOrderMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.items != nil && !minimock.Equal(*mm_want_ptrs.items, mm_got.items) {
				mmCreateOrder.t.Errorf("LomsMock.CreateOrder got unexpected parameter items, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateOrder.CreateOrderMock.defaultExpectation.expectationOrigins.originItems, *mm_want_ptrs.items, mm_got.items, minimock.Diff(*mm_want_ptrs.items, mm_got.items))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateOrder.t.Errorf("LomsMock.CreateOrder got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateOrder.CreateOrderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateOrder.CreateOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateOrder.t.Fatal("No results are set for the LomsMock.CreateOrder")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateOrder.funcCreateOrder != nil {
		return mmCreateOrder.funcCreateOrder(ctx, items)
	}
	mmCreateOrder.t.Fatalf("Unexpected call to LomsMock.CreateOrder. %v %v", ctx, items)
	return
}

// CreateOrderAfterCounter returns a count of finished LomsMock.CreateOrder invocations
func (mmCreateOrder *LomsMock) CreateOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrder.afterCreateOrderCounter)
}

// CreateOrderBeforeCounter returns a count of LomsMock.CreateOrder invocations
func (mmCreateOrder *LomsMock) CreateOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrder.beforeCreateOrderCounter)
}

// Calls returns a list of arguments used in each call to LomsMock.CreateOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateOrder *mLomsMockCreateOrder) Calls() []*LomsMockCreateOrderParams {
	mmCreateOrder.mutex.RLock()

	argCopy := make([]*LomsMockCreateOrderParams, len(mmCreateOrder.callArgs))
	copy(argCopy, mmCreateOrder.callArgs)

	mmCreateOrder.mutex.RUnlock()

	return argCopy
}

// MinimockCreateOrderDone returns true if the count of the CreateOrder invocations corresponds
// the number of defined expectations
func (m *LomsMock) MinimockCreateOrderDone() bool {
	if m.CreateOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateOrderMock.invocationsDone()
}

// MinimockCreateOrderInspect logs each unmet expectation
func (m *LomsMock) MinimockCreateOrderInspect() {
	for _, e := range m.CreateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LomsMock.CreateOrder at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateOrderCounter := mm_atomic.LoadUint64(&m.afterCreateOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateOrderMock.defaultExpectation != nil && afterCreateOrderCounter < 1 {
		if m.CreateOrderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LomsMock.CreateOrder at\n%s", m.CreateOrderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LomsMock.CreateOrder at\n%s with params: %#v", m.CreateOrderMock.defaultExpectation.expectationOrigins.origin, *m.CreateOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateOrder != nil && afterCreateOrderCounter < 1 {
		m.t.Errorf("Expected call to LomsMock.CreateOrder at\n%s", m.funcCreateOrderOrigin)
	}

	if !m.CreateOrderMock.invocationsDone() && afterCreateOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to LomsMock.CreateOrder at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateOrderMock.expectedInvocations), m.CreateOrderMock.expectedInvocationsOrigin, afterCreateOrderCounter)
	}
}

type mLomsMockIsProductAvailable struct {
	optional           bool
	mock               *LomsMock
	defaultExpectation *LomsMockIsProductAvailableExpectation
	expectations       []*LomsMockIsProductAvailableExpectation

	callArgs []*LomsMockIsProductAvailableParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// LomsMockIsProductAvailableExpectation specifies expectation struct of the Loms.IsProductAvailable
type LomsMockIsProductAvailableExpectation struct {
	mock               *LomsMock
	params             *LomsMockIsProductAvailableParams
	paramPtrs          *LomsMockIsProductAvailableParamPtrs
	expectationOrigins LomsMockIsProductAvailableExpectationOrigins
	results            *LomsMockIsProductAvailableResults
	returnOrigin       string
	Counter            uint64
}

// LomsMockIsProductAvailableParams contains parameters of the Loms.IsProductAvailable
type LomsMockIsProductAvailableParams struct {
	ctx   context.Context
	sku   int64
	count uint32
}

// LomsMockIsProductAvailableParamPtrs contains pointers to parameters of the Loms.IsProductAvailable
type LomsMockIsProductAvailableParamPtrs struct {
	ctx   *context.Context
	sku   *int64
	count *uint32
}

// LomsMockIsProductAvailableResults contains results of the Loms.IsProductAvailable
type LomsMockIsProductAvailableResults struct {
	b1  bool
	err error
}

// LomsMockIsProductAvailableOrigins contains origins of expectations of the Loms.IsProductAvailable
type LomsMockIsProductAvailableExpectationOrigins struct {
	origin      string
	originCtx   string
	originSku   string
	originCount string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmIsProductAvailable *mLomsMockIsProductAvailable) Optional() *mLomsMockIsProductAvailable {
	mmIsProductAvailable.optional = true
	return mmIsProductAvailable
}

// Expect sets up expected params for Loms.IsProductAvailable
func (mmIsProductAvailable *mLomsMockIsProductAvailable) Expect(ctx context.Context, sku int64, count uint32) *mLomsMockIsProductAvailable {
	if mmIsProductAvailable.mock.funcIsProductAvailable != nil {
		mmIsProductAvailable.mock.t.Fatalf("LomsMock.IsProductAvailable mock is already set by Set")
	}

	if mmIsProductAvailable.defaultExpectation == nil {
		mmIsProductAvailable.defaultExpectation = &LomsMockIsProductAvailableExpectation{}
	}

	if mmIsProductAvailable.defaultExpectation.paramPtrs != nil {
		mmIsProductAvailable.mock.t.Fatalf("LomsMock.IsProductAvailable mock is already set by ExpectParams functions")
	}

	mmIsProductAvailable.defaultExpectation.params = &LomsMockIsProductAvailableParams{ctx, sku, count}
	mmIsProductAvailable.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmIsProductAvailable.expectations {
		if minimock.Equal(e.params, mmIsProductAvailable.defaultExpectation.params) {
			mmIsProductAvailable.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIsProductAvailable.defaultExpectation.params)
		}
	}

	return mmIsProductAvailable
}

// ExpectCtxParam1 sets up expected param ctx for Loms.IsProductAvailable
func (mmIsProductAvailable *mLomsMockIsProductAvailable) ExpectCtxParam1(ctx context.Context) *mLomsMockIsProductAvailable {
	if mmIsProductAvailable.mock.funcIsProductAvailable != nil {
		mmIsProductAvailable.mock.t.Fatalf("LomsMock.IsProductAvailable mock is already set by Set")
	}

	if mmIsProductAvailable.defaultExpectation == nil {
		mmIsProductAvailable.defaultExpectation = &LomsMockIsProductAvailableExpectation{}
	}

	if mmIsProductAvailable.defaultExpectation.params != nil {
		mmIsProductAvailable.mock.t.Fatalf("LomsMock.IsProductAvailable mock is already set by Expect")
	}

	if mmIsProductAvailable.defaultExpectation.paramPtrs == nil {
		mmIsProductAvailable.defaultExpectation.paramPtrs = &LomsMockIsProductAvailableParamPtrs{}
	}
	mmIsProductAvailable.defaultExpectation.paramPtrs.ctx = &ctx
	mmIsProductAvailable.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmIsProductAvailable
}

// ExpectSkuParam2 sets up expected param sku for Loms.IsProductAvailable
func (mmIsProductAvailable *mLomsMockIsProductAvailable) ExpectSkuParam2(sku int64) *mLomsMockIsProductAvailable {
	if mmIsProductAvailable.mock.funcIsProductAvailable != nil {
		mmIsProductAvailable.mock.t.Fatalf("LomsMock.IsProductAvailable mock is already set by Set")
	}

	if mmIsProductAvailable.defaultExpectation == nil {
		mmIsProductAvailable.defaultExpectation = &LomsMockIsProductAvailableExpectation{}
	}

	if mmIsProductAvailable.defaultExpectation.params != nil {
		mmIsProductAvailable.mock.t.Fatalf("LomsMock.IsProductAvailable mock is already set by Expect")
	}

	if mmIsProductAvailable.defaultExpectation.paramPtrs == nil {
		mmIsProductAvailable.defaultExpectation.paramPtrs = &LomsMockIsProductAvailableParamPtrs{}
	}
	mmIsProductAvailable.defaultExpectation.paramPtrs.sku = &sku
	mmIsProductAvailable.defaultExpectation.expectationOrigins.originSku = minimock.CallerInfo(1)

	return mmIsProductAvailable
}

// ExpectCountParam3 sets up expected param count for Loms.IsProductAvailable
func (mmIsProductAvailable *mLomsMockIsProductAvailable) ExpectCountParam3(count uint32) *mLomsMockIsProductAvailable {
	if mmIsProductAvailable.mock.funcIsProductAvailable != nil {
		mmIsProductAvailable.mock.t.Fatalf("LomsMock.IsProductAvailable mock is already set by Set")
	}

	if mmIsProductAvailable.defaultExpectation == nil {
		mmIsProductAvailable.defaultExpectation = &LomsMockIsProductAvailableExpectation{}
	}

	if mmIsProductAvailable.defaultExpectation.params != nil {
		mmIsProductAvailable.mock.t.Fatalf("LomsMock.IsProductAvailable mock is already set by Expect")
	}

	if mmIsProductAvailable.defaultExpectation.paramPtrs == nil {
		mmIsProductAvailable.defaultExpectation.paramPtrs = &LomsMockIsProductAvailableParamPtrs{}
	}
	mmIsProductAvailable.defaultExpectation.paramPtrs.count = &count
	mmIsProductAvailable.defaultExpectation.expectationOrigins.originCount = minimock.CallerInfo(1)

	return mmIsProductAvailable
}

// Inspect accepts an inspector function that has same arguments as the Loms.IsProductAvailable
func (mmIsProductAvailable *mLomsMockIsProductAvailable) Inspect(f func(ctx context.Context, sku int64, count uint32)) *mLomsMockIsProductAvailable {
	if mmIsProductAvailable.mock.inspectFuncIsProductAvailable != nil {
		mmIsProductAvailable.mock.t.Fatalf("Inspect function is already set for LomsMock.IsProductAvailable")
	}

	mmIsProductAvailable.mock.inspectFuncIsProductAvailable = f

	return mmIsProductAvailable
}

// Return sets up results that will be returned by Loms.IsProductAvailable
func (mmIsProductAvailable *mLomsMockIsProductAvailable) Return(b1 bool, err error) *LomsMock {
	if mmIsProductAvailable.mock.funcIsProductAvailable != nil {
		mmIsProductAvailable.mock.t.Fatalf("LomsMock.IsProductAvailable mock is already set by Set")
	}

	if mmIsProductAvailable.defaultExpectation == nil {
		mmIsProductAvailable.defaultExpectation = &LomsMockIsProductAvailableExpectation{mock: mmIsProductAvailable.mock}
	}
	mmIsProductAvailable.defaultExpectation.results = &LomsMockIsProductAvailableResults{b1, err}
	mmIsProductAvailable.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmIsProductAvailable.mock
}

// Set uses given function f to mock the Loms.IsProductAvailable method
func (mmIsProductAvailable *mLomsMockIsProductAvailable) Set(f func(ctx context.Context, sku int64, count uint32) (b1 bool, err error)) *LomsMock {
	if mmIsProductAvailable.defaultExpectation != nil {
		mmIsProductAvailable.mock.t.Fatalf("Default expectation is already set for the Loms.IsProductAvailable method")
	}

	if len(mmIsProductAvailable.expectations) > 0 {
		mmIsProductAvailable.mock.t.Fatalf("Some expectations are already set for the Loms.IsProductAvailable method")
	}

	mmIsProductAvailable.mock.funcIsProductAvailable = f
	mmIsProductAvailable.mock.funcIsProductAvailableOrigin = minimock.CallerInfo(1)
	return mmIsProductAvailable.mock
}

// When sets expectation for the Loms.IsProductAvailable which will trigger the result defined by the following
// Then helper
func (mmIsProductAvailable *mLomsMockIsProductAvailable) When(ctx context.Context, sku int64, count uint32) *LomsMockIsProductAvailableExpectation {
	if mmIsProductAvailable.mock.funcIsProductAvailable != nil {
		mmIsProductAvailable.mock.t.Fatalf("LomsMock.IsProductAvailable mock is already set by Set")
	}

	expectation := &LomsMockIsProductAvailableExpectation{
		mock:               mmIsProductAvailable.mock,
		params:             &LomsMockIsProductAvailableParams{ctx, sku, count},
		expectationOrigins: LomsMockIsProductAvailableExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmIsProductAvailable.expectations = append(mmIsProductAvailable.expectations, expectation)
	return expectation
}

// Then sets up Loms.IsProductAvailable return parameters for the expectation previously defined by the When method
func (e *LomsMockIsProductAvailableExpectation) Then(b1 bool, err error) *LomsMock {
	e.results = &LomsMockIsProductAvailableResults{b1, err}
	return e.mock
}

// Times sets number of times Loms.IsProductAvailable should be invoked
func (mmIsProductAvailable *mLomsMockIsProductAvailable) Times(n uint64) *mLomsMockIsProductAvailable {
	if n == 0 {
		mmIsProductAvailable.mock.t.Fatalf("Times of LomsMock.IsProductAvailable mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmIsProductAvailable.expectedInvocations, n)
	mmIsProductAvailable.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmIsProductAvailable
}

func (mmIsProductAvailable *mLomsMockIsProductAvailable) invocationsDone() bool {
	if len(mmIsProductAvailable.expectations) == 0 && mmIsProductAvailable.defaultExpectation == nil && mmIsProductAvailable.mock.funcIsProductAvailable == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmIsProductAvailable.mock.afterIsProductAvailableCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmIsProductAvailable.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// IsProductAvailable implements mm_service.Loms
func (mmIsProductAvailable *LomsMock) IsProductAvailable(ctx context.Context, sku int64, count uint32) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmIsProductAvailable.beforeIsProductAvailableCounter, 1)
	defer mm_atomic.AddUint64(&mmIsProductAvailable.afterIsProductAvailableCounter, 1)

	mmIsProductAvailable.t.Helper()

	if mmIsProductAvailable.inspectFuncIsProductAvailable != nil {
		mmIsProductAvailable.inspectFuncIsProductAvailable(ctx, sku, count)
	}

	mm_params := LomsMockIsProductAvailableParams{ctx, sku, count}

	// Record call args
	mmIsProductAvailable.IsProductAvailableMock.mutex.Lock()
	mmIsProductAvailable.IsProductAvailableMock.callArgs = append(mmIsProductAvailable.IsProductAvailableMock.callArgs, &mm_params)
	mmIsProductAvailable.IsProductAvailableMock.mutex.Unlock()

	for _, e := range mmIsProductAvailable.IsProductAvailableMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmIsProductAvailable.IsProductAvailableMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsProductAvailable.IsProductAvailableMock.defaultExpectation.Counter, 1)
		mm_want := mmIsProductAvailable.IsProductAvailableMock.defaultExpectation.params
		mm_want_ptrs := mmIsProductAvailable.IsProductAvailableMock.defaultExpectation.paramPtrs

		mm_got := LomsMockIsProductAvailableParams{ctx, sku, count}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmIsProductAvailable.t.Errorf("LomsMock.IsProductAvailable got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIsProductAvailable.IsProductAvailableMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sku != nil && !minimock.Equal(*mm_want_ptrs.sku, mm_got.sku) {
				mmIsProductAvailable.t.Errorf("LomsMock.IsProductAvailable got unexpected parameter sku, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIsProductAvailable.IsProductAvailableMock.defaultExpectation.expectationOrigins.originSku, *mm_want_ptrs.sku, mm_got.sku, minimock.Diff(*mm_want_ptrs.sku, mm_got.sku))
			}

			if mm_want_ptrs.count != nil && !minimock.Equal(*mm_want_ptrs.count, mm_got.count) {
				mmIsProductAvailable.t.Errorf("LomsMock.IsProductAvailable got unexpected parameter count, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIsProductAvailable.IsProductAvailableMock.defaultExpectation.expectationOrigins.originCount, *mm_want_ptrs.count, mm_got.count, minimock.Diff(*mm_want_ptrs.count, mm_got.count))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIsProductAvailable.t.Errorf("LomsMock.IsProductAvailable got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmIsProductAvailable.IsProductAvailableMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIsProductAvailable.IsProductAvailableMock.defaultExpectation.results
		if mm_results == nil {
			mmIsProductAvailable.t.Fatal("No results are set for the LomsMock.IsProductAvailable")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmIsProductAvailable.funcIsProductAvailable != nil {
		return mmIsProductAvailable.funcIsProductAvailable(ctx, sku, count)
	}
	mmIsProductAvailable.t.Fatalf("Unexpected call to LomsMock.IsProductAvailable. %v %v %v", ctx, sku, count)
	return
}

// IsProductAvailableAfterCounter returns a count of finished LomsMock.IsProductAvailable invocations
func (mmIsProductAvailable *LomsMock) IsProductAvailableAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsProductAvailable.afterIsProductAvailableCounter)
}

// IsProductAvailableBeforeCounter returns a count of LomsMock.IsProductAvailable invocations
func (mmIsProductAvailable *LomsMock) IsProductAvailableBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsProductAvailable.beforeIsProductAvailableCounter)
}

// Calls returns a list of arguments used in each call to LomsMock.IsProductAvailable.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIsProductAvailable *mLomsMockIsProductAvailable) Calls() []*LomsMockIsProductAvailableParams {
	mmIsProductAvailable.mutex.RLock()

	argCopy := make([]*LomsMockIsProductAvailableParams, len(mmIsProductAvailable.callArgs))
	copy(argCopy, mmIsProductAvailable.callArgs)

	mmIsProductAvailable.mutex.RUnlock()

	return argCopy
}

// MinimockIsProductAvailableDone returns true if the count of the IsProductAvailable invocations corresponds
// the number of defined expectations
func (m *LomsMock) MinimockIsProductAvailableDone() bool {
	if m.IsProductAvailableMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.IsProductAvailableMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.IsProductAvailableMock.invocationsDone()
}

// MinimockIsProductAvailableInspect logs each unmet expectation
func (m *LomsMock) MinimockIsProductAvailableInspect() {
	for _, e := range m.IsProductAvailableMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to LomsMock.IsProductAvailable at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterIsProductAvailableCounter := mm_atomic.LoadUint64(&m.afterIsProductAvailableCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.IsProductAvailableMock.defaultExpectation != nil && afterIsProductAvailableCounter < 1 {
		if m.IsProductAvailableMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to LomsMock.IsProductAvailable at\n%s", m.IsProductAvailableMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to LomsMock.IsProductAvailable at\n%s with params: %#v", m.IsProductAvailableMock.defaultExpectation.expectationOrigins.origin, *m.IsProductAvailableMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsProductAvailable != nil && afterIsProductAvailableCounter < 1 {
		m.t.Errorf("Expected call to LomsMock.IsProductAvailable at\n%s", m.funcIsProductAvailableOrigin)
	}

	if !m.IsProductAvailableMock.invocationsDone() && afterIsProductAvailableCounter > 0 {
		m.t.Errorf("Expected %d calls to LomsMock.IsProductAvailable at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.IsProductAvailableMock.expectedInvocations), m.IsProductAvailableMock.expectedInvocationsOrigin, afterIsProductAvailableCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *LomsMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateOrderInspect()

			m.MinimockIsProductAvailableInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *LomsMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *LomsMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateOrderDone() &&
		m.MinimockIsProductAvailableDone()
}
