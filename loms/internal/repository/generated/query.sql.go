// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package generated

import (
	"context"
)

const addOrder = `-- name: AddOrder :one
INSERT INTO orders (user_id, status) VALUES ($1, 0) RETURNING id, user_id, status
`

func (q *Queries) AddOrder(ctx context.Context, userID int64) (*Order, error) {
	row := q.db.QueryRow(ctx, addOrder, userID)
	var i Order
	err := row.Scan(&i.ID, &i.UserID, &i.Status)
	return &i, err
}

const addOrderItem = `-- name: AddOrderItem :one
INSERT INTO orders_items (order_id, sku, count) VALUES ($1, $2, $3) RETURNING id, order_id, sku, count
`

type AddOrderItemParams struct {
	OrderID int64
	Sku     int64
	Count   int32
}

func (q *Queries) AddOrderItem(ctx context.Context, arg *AddOrderItemParams) (*OrdersItem, error) {
	row := q.db.QueryRow(ctx, addOrderItem, arg.OrderID, arg.Sku, arg.Count)
	var i OrdersItem
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.Sku,
		&i.Count,
	)
	return &i, err
}

const cancelOrder = `-- name: CancelOrder :exec
UPDATE orders SET status = 4 WHERE id = $1
`

func (q *Queries) CancelOrder(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, cancelOrder, id)
	return err
}

const failOrder = `-- name: FailOrder :exec
UPDATE orders SET status = 2 WHERE id = $1
`

func (q *Queries) FailOrder(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, failOrder, id)
	return err
}

const order = `-- name: Order :one
SELECT id, user_id, status FROM orders WHERE id = $1 LIMIT 1
`

func (q *Queries) Order(ctx context.Context, id int64) (*Order, error) {
	row := q.db.QueryRow(ctx, order, id)
	var i Order
	err := row.Scan(&i.ID, &i.UserID, &i.Status)
	return &i, err
}

const orderItems = `-- name: OrderItems :many
SELECT id, order_id, sku, count FROM orders_items WHERE order_id = $1
`

func (q *Queries) OrderItems(ctx context.Context, orderID int64) ([]*OrdersItem, error) {
	rows, err := q.db.Query(ctx, orderItems, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*OrdersItem
	for rows.Next() {
		var i OrdersItem
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.Sku,
			&i.Count,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const payOrder = `-- name: PayOrder :exec
UPDATE orders SET status = 3 WHERE id = $1
`

func (q *Queries) PayOrder(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, payOrder, id)
	return err
}

const setAwaitingPayment = `-- name: SetAwaitingPayment :exec
UPDATE orders SET status = 1 WHERE id = $1
`

func (q *Queries) SetAwaitingPayment(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, setAwaitingPayment, id)
	return err
}

const stock = `-- name: Stock :one
SELECT id, sku, total_count, reserved FROM stocks WHERE sku = $1 LIMIT 1
`

func (q *Queries) Stock(ctx context.Context, sku int64) (*Stock, error) {
	row := q.db.QueryRow(ctx, stock, sku)
	var i Stock
	err := row.Scan(
		&i.ID,
		&i.Sku,
		&i.TotalCount,
		&i.Reserved,
	)
	return &i, err
}

const updateStock = `-- name: UpdateStock :exec
UPDATE stocks SET reserved = $2, total_count = $3 WHERE sku = $1
`

type UpdateStockParams struct {
	Sku        int64
	Reserved   int32
	TotalCount int32
}

func (q *Queries) UpdateStock(ctx context.Context, arg *UpdateStockParams) error {
	_, err := q.db.Exec(ctx, updateStock, arg.Sku, arg.Reserved, arg.TotalCount)
	return err
}
