// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocked

//go:generate minimock -i route256/loms/internal/service.Orders -o orders_mock.go -n OrdersMock -p mocked

import (
	"context"
	loms "route256/loms/pkg/api/loms/v1"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// OrdersMock implements mm_service.Orders
type OrdersMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAwaitingPayment          func(ctx context.Context, id int64) (err error)
	funcAwaitingPaymentOrigin    string
	inspectFuncAwaitingPayment   func(ctx context.Context, id int64)
	afterAwaitingPaymentCounter  uint64
	beforeAwaitingPaymentCounter uint64
	AwaitingPaymentMock          mOrdersMockAwaitingPayment

	funcCancel          func(ctx context.Context, id int64) (err error)
	funcCancelOrigin    string
	inspectFuncCancel   func(ctx context.Context, id int64)
	afterCancelCounter  uint64
	beforeCancelCounter uint64
	CancelMock          mOrdersMockCancel

	funcCreate          func(ctx context.Context, userID int64, items []*loms.Item) (i1 int64, err error)
	funcCreateOrigin    string
	inspectFuncCreate   func(ctx context.Context, userID int64, items []*loms.Item)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mOrdersMockCreate

	funcFail          func(ctx context.Context, id int64) (err error)
	funcFailOrigin    string
	inspectFuncFail   func(ctx context.Context, id int64)
	afterFailCounter  uint64
	beforeFailCounter uint64
	FailMock          mOrdersMockFail

	funcOrder          func(ctx context.Context, id int64) (op1 *loms.Order, err error)
	funcOrderOrigin    string
	inspectFuncOrder   func(ctx context.Context, id int64)
	afterOrderCounter  uint64
	beforeOrderCounter uint64
	OrderMock          mOrdersMockOrder

	funcPay          func(ctx context.Context, id int64) (err error)
	funcPayOrigin    string
	inspectFuncPay   func(ctx context.Context, id int64)
	afterPayCounter  uint64
	beforePayCounter uint64
	PayMock          mOrdersMockPay
}

// NewOrdersMock returns a mock for mm_service.Orders
func NewOrdersMock(t minimock.Tester) *OrdersMock {
	m := &OrdersMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AwaitingPaymentMock = mOrdersMockAwaitingPayment{mock: m}
	m.AwaitingPaymentMock.callArgs = []*OrdersMockAwaitingPaymentParams{}

	m.CancelMock = mOrdersMockCancel{mock: m}
	m.CancelMock.callArgs = []*OrdersMockCancelParams{}

	m.CreateMock = mOrdersMockCreate{mock: m}
	m.CreateMock.callArgs = []*OrdersMockCreateParams{}

	m.FailMock = mOrdersMockFail{mock: m}
	m.FailMock.callArgs = []*OrdersMockFailParams{}

	m.OrderMock = mOrdersMockOrder{mock: m}
	m.OrderMock.callArgs = []*OrdersMockOrderParams{}

	m.PayMock = mOrdersMockPay{mock: m}
	m.PayMock.callArgs = []*OrdersMockPayParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mOrdersMockAwaitingPayment struct {
	optional           bool
	mock               *OrdersMock
	defaultExpectation *OrdersMockAwaitingPaymentExpectation
	expectations       []*OrdersMockAwaitingPaymentExpectation

	callArgs []*OrdersMockAwaitingPaymentParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrdersMockAwaitingPaymentExpectation specifies expectation struct of the Orders.AwaitingPayment
type OrdersMockAwaitingPaymentExpectation struct {
	mock               *OrdersMock
	params             *OrdersMockAwaitingPaymentParams
	paramPtrs          *OrdersMockAwaitingPaymentParamPtrs
	expectationOrigins OrdersMockAwaitingPaymentExpectationOrigins
	results            *OrdersMockAwaitingPaymentResults
	returnOrigin       string
	Counter            uint64
}

// OrdersMockAwaitingPaymentParams contains parameters of the Orders.AwaitingPayment
type OrdersMockAwaitingPaymentParams struct {
	ctx context.Context
	id  int64
}

// OrdersMockAwaitingPaymentParamPtrs contains pointers to parameters of the Orders.AwaitingPayment
type OrdersMockAwaitingPaymentParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// OrdersMockAwaitingPaymentResults contains results of the Orders.AwaitingPayment
type OrdersMockAwaitingPaymentResults struct {
	err error
}

// OrdersMockAwaitingPaymentOrigins contains origins of expectations of the Orders.AwaitingPayment
type OrdersMockAwaitingPaymentExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAwaitingPayment *mOrdersMockAwaitingPayment) Optional() *mOrdersMockAwaitingPayment {
	mmAwaitingPayment.optional = true
	return mmAwaitingPayment
}

// Expect sets up expected params for Orders.AwaitingPayment
func (mmAwaitingPayment *mOrdersMockAwaitingPayment) Expect(ctx context.Context, id int64) *mOrdersMockAwaitingPayment {
	if mmAwaitingPayment.mock.funcAwaitingPayment != nil {
		mmAwaitingPayment.mock.t.Fatalf("OrdersMock.AwaitingPayment mock is already set by Set")
	}

	if mmAwaitingPayment.defaultExpectation == nil {
		mmAwaitingPayment.defaultExpectation = &OrdersMockAwaitingPaymentExpectation{}
	}

	if mmAwaitingPayment.defaultExpectation.paramPtrs != nil {
		mmAwaitingPayment.mock.t.Fatalf("OrdersMock.AwaitingPayment mock is already set by ExpectParams functions")
	}

	mmAwaitingPayment.defaultExpectation.params = &OrdersMockAwaitingPaymentParams{ctx, id}
	mmAwaitingPayment.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAwaitingPayment.expectations {
		if minimock.Equal(e.params, mmAwaitingPayment.defaultExpectation.params) {
			mmAwaitingPayment.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAwaitingPayment.defaultExpectation.params)
		}
	}

	return mmAwaitingPayment
}

// ExpectCtxParam1 sets up expected param ctx for Orders.AwaitingPayment
func (mmAwaitingPayment *mOrdersMockAwaitingPayment) ExpectCtxParam1(ctx context.Context) *mOrdersMockAwaitingPayment {
	if mmAwaitingPayment.mock.funcAwaitingPayment != nil {
		mmAwaitingPayment.mock.t.Fatalf("OrdersMock.AwaitingPayment mock is already set by Set")
	}

	if mmAwaitingPayment.defaultExpectation == nil {
		mmAwaitingPayment.defaultExpectation = &OrdersMockAwaitingPaymentExpectation{}
	}

	if mmAwaitingPayment.defaultExpectation.params != nil {
		mmAwaitingPayment.mock.t.Fatalf("OrdersMock.AwaitingPayment mock is already set by Expect")
	}

	if mmAwaitingPayment.defaultExpectation.paramPtrs == nil {
		mmAwaitingPayment.defaultExpectation.paramPtrs = &OrdersMockAwaitingPaymentParamPtrs{}
	}
	mmAwaitingPayment.defaultExpectation.paramPtrs.ctx = &ctx
	mmAwaitingPayment.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAwaitingPayment
}

// ExpectIdParam2 sets up expected param id for Orders.AwaitingPayment
func (mmAwaitingPayment *mOrdersMockAwaitingPayment) ExpectIdParam2(id int64) *mOrdersMockAwaitingPayment {
	if mmAwaitingPayment.mock.funcAwaitingPayment != nil {
		mmAwaitingPayment.mock.t.Fatalf("OrdersMock.AwaitingPayment mock is already set by Set")
	}

	if mmAwaitingPayment.defaultExpectation == nil {
		mmAwaitingPayment.defaultExpectation = &OrdersMockAwaitingPaymentExpectation{}
	}

	if mmAwaitingPayment.defaultExpectation.params != nil {
		mmAwaitingPayment.mock.t.Fatalf("OrdersMock.AwaitingPayment mock is already set by Expect")
	}

	if mmAwaitingPayment.defaultExpectation.paramPtrs == nil {
		mmAwaitingPayment.defaultExpectation.paramPtrs = &OrdersMockAwaitingPaymentParamPtrs{}
	}
	mmAwaitingPayment.defaultExpectation.paramPtrs.id = &id
	mmAwaitingPayment.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmAwaitingPayment
}

// Inspect accepts an inspector function that has same arguments as the Orders.AwaitingPayment
func (mmAwaitingPayment *mOrdersMockAwaitingPayment) Inspect(f func(ctx context.Context, id int64)) *mOrdersMockAwaitingPayment {
	if mmAwaitingPayment.mock.inspectFuncAwaitingPayment != nil {
		mmAwaitingPayment.mock.t.Fatalf("Inspect function is already set for OrdersMock.AwaitingPayment")
	}

	mmAwaitingPayment.mock.inspectFuncAwaitingPayment = f

	return mmAwaitingPayment
}

// Return sets up results that will be returned by Orders.AwaitingPayment
func (mmAwaitingPayment *mOrdersMockAwaitingPayment) Return(err error) *OrdersMock {
	if mmAwaitingPayment.mock.funcAwaitingPayment != nil {
		mmAwaitingPayment.mock.t.Fatalf("OrdersMock.AwaitingPayment mock is already set by Set")
	}

	if mmAwaitingPayment.defaultExpectation == nil {
		mmAwaitingPayment.defaultExpectation = &OrdersMockAwaitingPaymentExpectation{mock: mmAwaitingPayment.mock}
	}
	mmAwaitingPayment.defaultExpectation.results = &OrdersMockAwaitingPaymentResults{err}
	mmAwaitingPayment.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAwaitingPayment.mock
}

// Set uses given function f to mock the Orders.AwaitingPayment method
func (mmAwaitingPayment *mOrdersMockAwaitingPayment) Set(f func(ctx context.Context, id int64) (err error)) *OrdersMock {
	if mmAwaitingPayment.defaultExpectation != nil {
		mmAwaitingPayment.mock.t.Fatalf("Default expectation is already set for the Orders.AwaitingPayment method")
	}

	if len(mmAwaitingPayment.expectations) > 0 {
		mmAwaitingPayment.mock.t.Fatalf("Some expectations are already set for the Orders.AwaitingPayment method")
	}

	mmAwaitingPayment.mock.funcAwaitingPayment = f
	mmAwaitingPayment.mock.funcAwaitingPaymentOrigin = minimock.CallerInfo(1)
	return mmAwaitingPayment.mock
}

// When sets expectation for the Orders.AwaitingPayment which will trigger the result defined by the following
// Then helper
func (mmAwaitingPayment *mOrdersMockAwaitingPayment) When(ctx context.Context, id int64) *OrdersMockAwaitingPaymentExpectation {
	if mmAwaitingPayment.mock.funcAwaitingPayment != nil {
		mmAwaitingPayment.mock.t.Fatalf("OrdersMock.AwaitingPayment mock is already set by Set")
	}

	expectation := &OrdersMockAwaitingPaymentExpectation{
		mock:               mmAwaitingPayment.mock,
		params:             &OrdersMockAwaitingPaymentParams{ctx, id},
		expectationOrigins: OrdersMockAwaitingPaymentExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAwaitingPayment.expectations = append(mmAwaitingPayment.expectations, expectation)
	return expectation
}

// Then sets up Orders.AwaitingPayment return parameters for the expectation previously defined by the When method
func (e *OrdersMockAwaitingPaymentExpectation) Then(err error) *OrdersMock {
	e.results = &OrdersMockAwaitingPaymentResults{err}
	return e.mock
}

// Times sets number of times Orders.AwaitingPayment should be invoked
func (mmAwaitingPayment *mOrdersMockAwaitingPayment) Times(n uint64) *mOrdersMockAwaitingPayment {
	if n == 0 {
		mmAwaitingPayment.mock.t.Fatalf("Times of OrdersMock.AwaitingPayment mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAwaitingPayment.expectedInvocations, n)
	mmAwaitingPayment.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAwaitingPayment
}

func (mmAwaitingPayment *mOrdersMockAwaitingPayment) invocationsDone() bool {
	if len(mmAwaitingPayment.expectations) == 0 && mmAwaitingPayment.defaultExpectation == nil && mmAwaitingPayment.mock.funcAwaitingPayment == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAwaitingPayment.mock.afterAwaitingPaymentCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAwaitingPayment.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AwaitingPayment implements mm_service.Orders
func (mmAwaitingPayment *OrdersMock) AwaitingPayment(ctx context.Context, id int64) (err error) {
	mm_atomic.AddUint64(&mmAwaitingPayment.beforeAwaitingPaymentCounter, 1)
	defer mm_atomic.AddUint64(&mmAwaitingPayment.afterAwaitingPaymentCounter, 1)

	mmAwaitingPayment.t.Helper()

	if mmAwaitingPayment.inspectFuncAwaitingPayment != nil {
		mmAwaitingPayment.inspectFuncAwaitingPayment(ctx, id)
	}

	mm_params := OrdersMockAwaitingPaymentParams{ctx, id}

	// Record call args
	mmAwaitingPayment.AwaitingPaymentMock.mutex.Lock()
	mmAwaitingPayment.AwaitingPaymentMock.callArgs = append(mmAwaitingPayment.AwaitingPaymentMock.callArgs, &mm_params)
	mmAwaitingPayment.AwaitingPaymentMock.mutex.Unlock()

	for _, e := range mmAwaitingPayment.AwaitingPaymentMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAwaitingPayment.AwaitingPaymentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAwaitingPayment.AwaitingPaymentMock.defaultExpectation.Counter, 1)
		mm_want := mmAwaitingPayment.AwaitingPaymentMock.defaultExpectation.params
		mm_want_ptrs := mmAwaitingPayment.AwaitingPaymentMock.defaultExpectation.paramPtrs

		mm_got := OrdersMockAwaitingPaymentParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAwaitingPayment.t.Errorf("OrdersMock.AwaitingPayment got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAwaitingPayment.AwaitingPaymentMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmAwaitingPayment.t.Errorf("OrdersMock.AwaitingPayment got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAwaitingPayment.AwaitingPaymentMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAwaitingPayment.t.Errorf("OrdersMock.AwaitingPayment got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAwaitingPayment.AwaitingPaymentMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAwaitingPayment.AwaitingPaymentMock.defaultExpectation.results
		if mm_results == nil {
			mmAwaitingPayment.t.Fatal("No results are set for the OrdersMock.AwaitingPayment")
		}
		return (*mm_results).err
	}
	if mmAwaitingPayment.funcAwaitingPayment != nil {
		return mmAwaitingPayment.funcAwaitingPayment(ctx, id)
	}
	mmAwaitingPayment.t.Fatalf("Unexpected call to OrdersMock.AwaitingPayment. %v %v", ctx, id)
	return
}

// AwaitingPaymentAfterCounter returns a count of finished OrdersMock.AwaitingPayment invocations
func (mmAwaitingPayment *OrdersMock) AwaitingPaymentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAwaitingPayment.afterAwaitingPaymentCounter)
}

// AwaitingPaymentBeforeCounter returns a count of OrdersMock.AwaitingPayment invocations
func (mmAwaitingPayment *OrdersMock) AwaitingPaymentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAwaitingPayment.beforeAwaitingPaymentCounter)
}

// Calls returns a list of arguments used in each call to OrdersMock.AwaitingPayment.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAwaitingPayment *mOrdersMockAwaitingPayment) Calls() []*OrdersMockAwaitingPaymentParams {
	mmAwaitingPayment.mutex.RLock()

	argCopy := make([]*OrdersMockAwaitingPaymentParams, len(mmAwaitingPayment.callArgs))
	copy(argCopy, mmAwaitingPayment.callArgs)

	mmAwaitingPayment.mutex.RUnlock()

	return argCopy
}

// MinimockAwaitingPaymentDone returns true if the count of the AwaitingPayment invocations corresponds
// the number of defined expectations
func (m *OrdersMock) MinimockAwaitingPaymentDone() bool {
	if m.AwaitingPaymentMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AwaitingPaymentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AwaitingPaymentMock.invocationsDone()
}

// MinimockAwaitingPaymentInspect logs each unmet expectation
func (m *OrdersMock) MinimockAwaitingPaymentInspect() {
	for _, e := range m.AwaitingPaymentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrdersMock.AwaitingPayment at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAwaitingPaymentCounter := mm_atomic.LoadUint64(&m.afterAwaitingPaymentCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AwaitingPaymentMock.defaultExpectation != nil && afterAwaitingPaymentCounter < 1 {
		if m.AwaitingPaymentMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrdersMock.AwaitingPayment at\n%s", m.AwaitingPaymentMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrdersMock.AwaitingPayment at\n%s with params: %#v", m.AwaitingPaymentMock.defaultExpectation.expectationOrigins.origin, *m.AwaitingPaymentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAwaitingPayment != nil && afterAwaitingPaymentCounter < 1 {
		m.t.Errorf("Expected call to OrdersMock.AwaitingPayment at\n%s", m.funcAwaitingPaymentOrigin)
	}

	if !m.AwaitingPaymentMock.invocationsDone() && afterAwaitingPaymentCounter > 0 {
		m.t.Errorf("Expected %d calls to OrdersMock.AwaitingPayment at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AwaitingPaymentMock.expectedInvocations), m.AwaitingPaymentMock.expectedInvocationsOrigin, afterAwaitingPaymentCounter)
	}
}

type mOrdersMockCancel struct {
	optional           bool
	mock               *OrdersMock
	defaultExpectation *OrdersMockCancelExpectation
	expectations       []*OrdersMockCancelExpectation

	callArgs []*OrdersMockCancelParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrdersMockCancelExpectation specifies expectation struct of the Orders.Cancel
type OrdersMockCancelExpectation struct {
	mock               *OrdersMock
	params             *OrdersMockCancelParams
	paramPtrs          *OrdersMockCancelParamPtrs
	expectationOrigins OrdersMockCancelExpectationOrigins
	results            *OrdersMockCancelResults
	returnOrigin       string
	Counter            uint64
}

// OrdersMockCancelParams contains parameters of the Orders.Cancel
type OrdersMockCancelParams struct {
	ctx context.Context
	id  int64
}

// OrdersMockCancelParamPtrs contains pointers to parameters of the Orders.Cancel
type OrdersMockCancelParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// OrdersMockCancelResults contains results of the Orders.Cancel
type OrdersMockCancelResults struct {
	err error
}

// OrdersMockCancelOrigins contains origins of expectations of the Orders.Cancel
type OrdersMockCancelExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCancel *mOrdersMockCancel) Optional() *mOrdersMockCancel {
	mmCancel.optional = true
	return mmCancel
}

// Expect sets up expected params for Orders.Cancel
func (mmCancel *mOrdersMockCancel) Expect(ctx context.Context, id int64) *mOrdersMockCancel {
	if mmCancel.mock.funcCancel != nil {
		mmCancel.mock.t.Fatalf("OrdersMock.Cancel mock is already set by Set")
	}

	if mmCancel.defaultExpectation == nil {
		mmCancel.defaultExpectation = &OrdersMockCancelExpectation{}
	}

	if mmCancel.defaultExpectation.paramPtrs != nil {
		mmCancel.mock.t.Fatalf("OrdersMock.Cancel mock is already set by ExpectParams functions")
	}

	mmCancel.defaultExpectation.params = &OrdersMockCancelParams{ctx, id}
	mmCancel.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCancel.expectations {
		if minimock.Equal(e.params, mmCancel.defaultExpectation.params) {
			mmCancel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCancel.defaultExpectation.params)
		}
	}

	return mmCancel
}

// ExpectCtxParam1 sets up expected param ctx for Orders.Cancel
func (mmCancel *mOrdersMockCancel) ExpectCtxParam1(ctx context.Context) *mOrdersMockCancel {
	if mmCancel.mock.funcCancel != nil {
		mmCancel.mock.t.Fatalf("OrdersMock.Cancel mock is already set by Set")
	}

	if mmCancel.defaultExpectation == nil {
		mmCancel.defaultExpectation = &OrdersMockCancelExpectation{}
	}

	if mmCancel.defaultExpectation.params != nil {
		mmCancel.mock.t.Fatalf("OrdersMock.Cancel mock is already set by Expect")
	}

	if mmCancel.defaultExpectation.paramPtrs == nil {
		mmCancel.defaultExpectation.paramPtrs = &OrdersMockCancelParamPtrs{}
	}
	mmCancel.defaultExpectation.paramPtrs.ctx = &ctx
	mmCancel.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCancel
}

// ExpectIdParam2 sets up expected param id for Orders.Cancel
func (mmCancel *mOrdersMockCancel) ExpectIdParam2(id int64) *mOrdersMockCancel {
	if mmCancel.mock.funcCancel != nil {
		mmCancel.mock.t.Fatalf("OrdersMock.Cancel mock is already set by Set")
	}

	if mmCancel.defaultExpectation == nil {
		mmCancel.defaultExpectation = &OrdersMockCancelExpectation{}
	}

	if mmCancel.defaultExpectation.params != nil {
		mmCancel.mock.t.Fatalf("OrdersMock.Cancel mock is already set by Expect")
	}

	if mmCancel.defaultExpectation.paramPtrs == nil {
		mmCancel.defaultExpectation.paramPtrs = &OrdersMockCancelParamPtrs{}
	}
	mmCancel.defaultExpectation.paramPtrs.id = &id
	mmCancel.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmCancel
}

// Inspect accepts an inspector function that has same arguments as the Orders.Cancel
func (mmCancel *mOrdersMockCancel) Inspect(f func(ctx context.Context, id int64)) *mOrdersMockCancel {
	if mmCancel.mock.inspectFuncCancel != nil {
		mmCancel.mock.t.Fatalf("Inspect function is already set for OrdersMock.Cancel")
	}

	mmCancel.mock.inspectFuncCancel = f

	return mmCancel
}

// Return sets up results that will be returned by Orders.Cancel
func (mmCancel *mOrdersMockCancel) Return(err error) *OrdersMock {
	if mmCancel.mock.funcCancel != nil {
		mmCancel.mock.t.Fatalf("OrdersMock.Cancel mock is already set by Set")
	}

	if mmCancel.defaultExpectation == nil {
		mmCancel.defaultExpectation = &OrdersMockCancelExpectation{mock: mmCancel.mock}
	}
	mmCancel.defaultExpectation.results = &OrdersMockCancelResults{err}
	mmCancel.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCancel.mock
}

// Set uses given function f to mock the Orders.Cancel method
func (mmCancel *mOrdersMockCancel) Set(f func(ctx context.Context, id int64) (err error)) *OrdersMock {
	if mmCancel.defaultExpectation != nil {
		mmCancel.mock.t.Fatalf("Default expectation is already set for the Orders.Cancel method")
	}

	if len(mmCancel.expectations) > 0 {
		mmCancel.mock.t.Fatalf("Some expectations are already set for the Orders.Cancel method")
	}

	mmCancel.mock.funcCancel = f
	mmCancel.mock.funcCancelOrigin = minimock.CallerInfo(1)
	return mmCancel.mock
}

// When sets expectation for the Orders.Cancel which will trigger the result defined by the following
// Then helper
func (mmCancel *mOrdersMockCancel) When(ctx context.Context, id int64) *OrdersMockCancelExpectation {
	if mmCancel.mock.funcCancel != nil {
		mmCancel.mock.t.Fatalf("OrdersMock.Cancel mock is already set by Set")
	}

	expectation := &OrdersMockCancelExpectation{
		mock:               mmCancel.mock,
		params:             &OrdersMockCancelParams{ctx, id},
		expectationOrigins: OrdersMockCancelExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCancel.expectations = append(mmCancel.expectations, expectation)
	return expectation
}

// Then sets up Orders.Cancel return parameters for the expectation previously defined by the When method
func (e *OrdersMockCancelExpectation) Then(err error) *OrdersMock {
	e.results = &OrdersMockCancelResults{err}
	return e.mock
}

// Times sets number of times Orders.Cancel should be invoked
func (mmCancel *mOrdersMockCancel) Times(n uint64) *mOrdersMockCancel {
	if n == 0 {
		mmCancel.mock.t.Fatalf("Times of OrdersMock.Cancel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCancel.expectedInvocations, n)
	mmCancel.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCancel
}

func (mmCancel *mOrdersMockCancel) invocationsDone() bool {
	if len(mmCancel.expectations) == 0 && mmCancel.defaultExpectation == nil && mmCancel.mock.funcCancel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCancel.mock.afterCancelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCancel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Cancel implements mm_service.Orders
func (mmCancel *OrdersMock) Cancel(ctx context.Context, id int64) (err error) {
	mm_atomic.AddUint64(&mmCancel.beforeCancelCounter, 1)
	defer mm_atomic.AddUint64(&mmCancel.afterCancelCounter, 1)

	mmCancel.t.Helper()

	if mmCancel.inspectFuncCancel != nil {
		mmCancel.inspectFuncCancel(ctx, id)
	}

	mm_params := OrdersMockCancelParams{ctx, id}

	// Record call args
	mmCancel.CancelMock.mutex.Lock()
	mmCancel.CancelMock.callArgs = append(mmCancel.CancelMock.callArgs, &mm_params)
	mmCancel.CancelMock.mutex.Unlock()

	for _, e := range mmCancel.CancelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCancel.CancelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCancel.CancelMock.defaultExpectation.Counter, 1)
		mm_want := mmCancel.CancelMock.defaultExpectation.params
		mm_want_ptrs := mmCancel.CancelMock.defaultExpectation.paramPtrs

		mm_got := OrdersMockCancelParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCancel.t.Errorf("OrdersMock.Cancel got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCancel.CancelMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmCancel.t.Errorf("OrdersMock.Cancel got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCancel.CancelMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCancel.t.Errorf("OrdersMock.Cancel got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCancel.CancelMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCancel.CancelMock.defaultExpectation.results
		if mm_results == nil {
			mmCancel.t.Fatal("No results are set for the OrdersMock.Cancel")
		}
		return (*mm_results).err
	}
	if mmCancel.funcCancel != nil {
		return mmCancel.funcCancel(ctx, id)
	}
	mmCancel.t.Fatalf("Unexpected call to OrdersMock.Cancel. %v %v", ctx, id)
	return
}

// CancelAfterCounter returns a count of finished OrdersMock.Cancel invocations
func (mmCancel *OrdersMock) CancelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCancel.afterCancelCounter)
}

// CancelBeforeCounter returns a count of OrdersMock.Cancel invocations
func (mmCancel *OrdersMock) CancelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCancel.beforeCancelCounter)
}

// Calls returns a list of arguments used in each call to OrdersMock.Cancel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCancel *mOrdersMockCancel) Calls() []*OrdersMockCancelParams {
	mmCancel.mutex.RLock()

	argCopy := make([]*OrdersMockCancelParams, len(mmCancel.callArgs))
	copy(argCopy, mmCancel.callArgs)

	mmCancel.mutex.RUnlock()

	return argCopy
}

// MinimockCancelDone returns true if the count of the Cancel invocations corresponds
// the number of defined expectations
func (m *OrdersMock) MinimockCancelDone() bool {
	if m.CancelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CancelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CancelMock.invocationsDone()
}

// MinimockCancelInspect logs each unmet expectation
func (m *OrdersMock) MinimockCancelInspect() {
	for _, e := range m.CancelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrdersMock.Cancel at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCancelCounter := mm_atomic.LoadUint64(&m.afterCancelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CancelMock.defaultExpectation != nil && afterCancelCounter < 1 {
		if m.CancelMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrdersMock.Cancel at\n%s", m.CancelMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrdersMock.Cancel at\n%s with params: %#v", m.CancelMock.defaultExpectation.expectationOrigins.origin, *m.CancelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCancel != nil && afterCancelCounter < 1 {
		m.t.Errorf("Expected call to OrdersMock.Cancel at\n%s", m.funcCancelOrigin)
	}

	if !m.CancelMock.invocationsDone() && afterCancelCounter > 0 {
		m.t.Errorf("Expected %d calls to OrdersMock.Cancel at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CancelMock.expectedInvocations), m.CancelMock.expectedInvocationsOrigin, afterCancelCounter)
	}
}

type mOrdersMockCreate struct {
	optional           bool
	mock               *OrdersMock
	defaultExpectation *OrdersMockCreateExpectation
	expectations       []*OrdersMockCreateExpectation

	callArgs []*OrdersMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrdersMockCreateExpectation specifies expectation struct of the Orders.Create
type OrdersMockCreateExpectation struct {
	mock               *OrdersMock
	params             *OrdersMockCreateParams
	paramPtrs          *OrdersMockCreateParamPtrs
	expectationOrigins OrdersMockCreateExpectationOrigins
	results            *OrdersMockCreateResults
	returnOrigin       string
	Counter            uint64
}

// OrdersMockCreateParams contains parameters of the Orders.Create
type OrdersMockCreateParams struct {
	ctx    context.Context
	userID int64
	items  []*loms.Item
}

// OrdersMockCreateParamPtrs contains pointers to parameters of the Orders.Create
type OrdersMockCreateParamPtrs struct {
	ctx    *context.Context
	userID *int64
	items  *[]*loms.Item
}

// OrdersMockCreateResults contains results of the Orders.Create
type OrdersMockCreateResults struct {
	i1  int64
	err error
}

// OrdersMockCreateOrigins contains origins of expectations of the Orders.Create
type OrdersMockCreateExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserID string
	originItems  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mOrdersMockCreate) Optional() *mOrdersMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for Orders.Create
func (mmCreate *mOrdersMockCreate) Expect(ctx context.Context, userID int64, items []*loms.Item) *mOrdersMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OrdersMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &OrdersMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("OrdersMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &OrdersMockCreateParams{ctx, userID, items}
	mmCreate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectCtxParam1 sets up expected param ctx for Orders.Create
func (mmCreate *mOrdersMockCreate) ExpectCtxParam1(ctx context.Context) *mOrdersMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OrdersMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &OrdersMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("OrdersMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &OrdersMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreate
}

// ExpectUserIDParam2 sets up expected param userID for Orders.Create
func (mmCreate *mOrdersMockCreate) ExpectUserIDParam2(userID int64) *mOrdersMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OrdersMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &OrdersMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("OrdersMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &OrdersMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.userID = &userID
	mmCreate.defaultExpectation.expectationOrigins.originUserID = minimock.CallerInfo(1)

	return mmCreate
}

// ExpectItemsParam3 sets up expected param items for Orders.Create
func (mmCreate *mOrdersMockCreate) ExpectItemsParam3(items []*loms.Item) *mOrdersMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OrdersMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &OrdersMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("OrdersMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &OrdersMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.items = &items
	mmCreate.defaultExpectation.expectationOrigins.originItems = minimock.CallerInfo(1)

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the Orders.Create
func (mmCreate *mOrdersMockCreate) Inspect(f func(ctx context.Context, userID int64, items []*loms.Item)) *mOrdersMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for OrdersMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by Orders.Create
func (mmCreate *mOrdersMockCreate) Return(i1 int64, err error) *OrdersMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OrdersMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &OrdersMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &OrdersMockCreateResults{i1, err}
	mmCreate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// Set uses given function f to mock the Orders.Create method
func (mmCreate *mOrdersMockCreate) Set(f func(ctx context.Context, userID int64, items []*loms.Item) (i1 int64, err error)) *OrdersMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the Orders.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the Orders.Create method")
	}

	mmCreate.mock.funcCreate = f
	mmCreate.mock.funcCreateOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// When sets expectation for the Orders.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mOrdersMockCreate) When(ctx context.Context, userID int64, items []*loms.Item) *OrdersMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("OrdersMock.Create mock is already set by Set")
	}

	expectation := &OrdersMockCreateExpectation{
		mock:               mmCreate.mock,
		params:             &OrdersMockCreateParams{ctx, userID, items},
		expectationOrigins: OrdersMockCreateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up Orders.Create return parameters for the expectation previously defined by the When method
func (e *OrdersMockCreateExpectation) Then(i1 int64, err error) *OrdersMock {
	e.results = &OrdersMockCreateResults{i1, err}
	return e.mock
}

// Times sets number of times Orders.Create should be invoked
func (mmCreate *mOrdersMockCreate) Times(n uint64) *mOrdersMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of OrdersMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	mmCreate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreate
}

func (mmCreate *mOrdersMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements mm_service.Orders
func (mmCreate *OrdersMock) Create(ctx context.Context, userID int64, items []*loms.Item) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	mmCreate.t.Helper()

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, userID, items)
	}

	mm_params := OrdersMockCreateParams{ctx, userID, items}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := OrdersMockCreateParams{ctx, userID, items}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreate.t.Errorf("OrdersMock.Create got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userID != nil && !minimock.Equal(*mm_want_ptrs.userID, mm_got.userID) {
				mmCreate.t.Errorf("OrdersMock.Create got unexpected parameter userID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originUserID, *mm_want_ptrs.userID, mm_got.userID, minimock.Diff(*mm_want_ptrs.userID, mm_got.userID))
			}

			if mm_want_ptrs.items != nil && !minimock.Equal(*mm_want_ptrs.items, mm_got.items) {
				mmCreate.t.Errorf("OrdersMock.Create got unexpected parameter items, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originItems, *mm_want_ptrs.items, mm_got.items, minimock.Diff(*mm_want_ptrs.items, mm_got.items))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("OrdersMock.Create got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreate.CreateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the OrdersMock.Create")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, userID, items)
	}
	mmCreate.t.Fatalf("Unexpected call to OrdersMock.Create. %v %v %v", ctx, userID, items)
	return
}

// CreateAfterCounter returns a count of finished OrdersMock.Create invocations
func (mmCreate *OrdersMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of OrdersMock.Create invocations
func (mmCreate *OrdersMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to OrdersMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mOrdersMockCreate) Calls() []*OrdersMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*OrdersMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *OrdersMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *OrdersMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrdersMock.Create at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrdersMock.Create at\n%s", m.CreateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrdersMock.Create at\n%s with params: %#v", m.CreateMock.defaultExpectation.expectationOrigins.origin, *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Errorf("Expected call to OrdersMock.Create at\n%s", m.funcCreateOrigin)
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to OrdersMock.Create at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), m.CreateMock.expectedInvocationsOrigin, afterCreateCounter)
	}
}

type mOrdersMockFail struct {
	optional           bool
	mock               *OrdersMock
	defaultExpectation *OrdersMockFailExpectation
	expectations       []*OrdersMockFailExpectation

	callArgs []*OrdersMockFailParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrdersMockFailExpectation specifies expectation struct of the Orders.Fail
type OrdersMockFailExpectation struct {
	mock               *OrdersMock
	params             *OrdersMockFailParams
	paramPtrs          *OrdersMockFailParamPtrs
	expectationOrigins OrdersMockFailExpectationOrigins
	results            *OrdersMockFailResults
	returnOrigin       string
	Counter            uint64
}

// OrdersMockFailParams contains parameters of the Orders.Fail
type OrdersMockFailParams struct {
	ctx context.Context
	id  int64
}

// OrdersMockFailParamPtrs contains pointers to parameters of the Orders.Fail
type OrdersMockFailParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// OrdersMockFailResults contains results of the Orders.Fail
type OrdersMockFailResults struct {
	err error
}

// OrdersMockFailOrigins contains origins of expectations of the Orders.Fail
type OrdersMockFailExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFail *mOrdersMockFail) Optional() *mOrdersMockFail {
	mmFail.optional = true
	return mmFail
}

// Expect sets up expected params for Orders.Fail
func (mmFail *mOrdersMockFail) Expect(ctx context.Context, id int64) *mOrdersMockFail {
	if mmFail.mock.funcFail != nil {
		mmFail.mock.t.Fatalf("OrdersMock.Fail mock is already set by Set")
	}

	if mmFail.defaultExpectation == nil {
		mmFail.defaultExpectation = &OrdersMockFailExpectation{}
	}

	if mmFail.defaultExpectation.paramPtrs != nil {
		mmFail.mock.t.Fatalf("OrdersMock.Fail mock is already set by ExpectParams functions")
	}

	mmFail.defaultExpectation.params = &OrdersMockFailParams{ctx, id}
	mmFail.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmFail.expectations {
		if minimock.Equal(e.params, mmFail.defaultExpectation.params) {
			mmFail.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFail.defaultExpectation.params)
		}
	}

	return mmFail
}

// ExpectCtxParam1 sets up expected param ctx for Orders.Fail
func (mmFail *mOrdersMockFail) ExpectCtxParam1(ctx context.Context) *mOrdersMockFail {
	if mmFail.mock.funcFail != nil {
		mmFail.mock.t.Fatalf("OrdersMock.Fail mock is already set by Set")
	}

	if mmFail.defaultExpectation == nil {
		mmFail.defaultExpectation = &OrdersMockFailExpectation{}
	}

	if mmFail.defaultExpectation.params != nil {
		mmFail.mock.t.Fatalf("OrdersMock.Fail mock is already set by Expect")
	}

	if mmFail.defaultExpectation.paramPtrs == nil {
		mmFail.defaultExpectation.paramPtrs = &OrdersMockFailParamPtrs{}
	}
	mmFail.defaultExpectation.paramPtrs.ctx = &ctx
	mmFail.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmFail
}

// ExpectIdParam2 sets up expected param id for Orders.Fail
func (mmFail *mOrdersMockFail) ExpectIdParam2(id int64) *mOrdersMockFail {
	if mmFail.mock.funcFail != nil {
		mmFail.mock.t.Fatalf("OrdersMock.Fail mock is already set by Set")
	}

	if mmFail.defaultExpectation == nil {
		mmFail.defaultExpectation = &OrdersMockFailExpectation{}
	}

	if mmFail.defaultExpectation.params != nil {
		mmFail.mock.t.Fatalf("OrdersMock.Fail mock is already set by Expect")
	}

	if mmFail.defaultExpectation.paramPtrs == nil {
		mmFail.defaultExpectation.paramPtrs = &OrdersMockFailParamPtrs{}
	}
	mmFail.defaultExpectation.paramPtrs.id = &id
	mmFail.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmFail
}

// Inspect accepts an inspector function that has same arguments as the Orders.Fail
func (mmFail *mOrdersMockFail) Inspect(f func(ctx context.Context, id int64)) *mOrdersMockFail {
	if mmFail.mock.inspectFuncFail != nil {
		mmFail.mock.t.Fatalf("Inspect function is already set for OrdersMock.Fail")
	}

	mmFail.mock.inspectFuncFail = f

	return mmFail
}

// Return sets up results that will be returned by Orders.Fail
func (mmFail *mOrdersMockFail) Return(err error) *OrdersMock {
	if mmFail.mock.funcFail != nil {
		mmFail.mock.t.Fatalf("OrdersMock.Fail mock is already set by Set")
	}

	if mmFail.defaultExpectation == nil {
		mmFail.defaultExpectation = &OrdersMockFailExpectation{mock: mmFail.mock}
	}
	mmFail.defaultExpectation.results = &OrdersMockFailResults{err}
	mmFail.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmFail.mock
}

// Set uses given function f to mock the Orders.Fail method
func (mmFail *mOrdersMockFail) Set(f func(ctx context.Context, id int64) (err error)) *OrdersMock {
	if mmFail.defaultExpectation != nil {
		mmFail.mock.t.Fatalf("Default expectation is already set for the Orders.Fail method")
	}

	if len(mmFail.expectations) > 0 {
		mmFail.mock.t.Fatalf("Some expectations are already set for the Orders.Fail method")
	}

	mmFail.mock.funcFail = f
	mmFail.mock.funcFailOrigin = minimock.CallerInfo(1)
	return mmFail.mock
}

// When sets expectation for the Orders.Fail which will trigger the result defined by the following
// Then helper
func (mmFail *mOrdersMockFail) When(ctx context.Context, id int64) *OrdersMockFailExpectation {
	if mmFail.mock.funcFail != nil {
		mmFail.mock.t.Fatalf("OrdersMock.Fail mock is already set by Set")
	}

	expectation := &OrdersMockFailExpectation{
		mock:               mmFail.mock,
		params:             &OrdersMockFailParams{ctx, id},
		expectationOrigins: OrdersMockFailExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmFail.expectations = append(mmFail.expectations, expectation)
	return expectation
}

// Then sets up Orders.Fail return parameters for the expectation previously defined by the When method
func (e *OrdersMockFailExpectation) Then(err error) *OrdersMock {
	e.results = &OrdersMockFailResults{err}
	return e.mock
}

// Times sets number of times Orders.Fail should be invoked
func (mmFail *mOrdersMockFail) Times(n uint64) *mOrdersMockFail {
	if n == 0 {
		mmFail.mock.t.Fatalf("Times of OrdersMock.Fail mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmFail.expectedInvocations, n)
	mmFail.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmFail
}

func (mmFail *mOrdersMockFail) invocationsDone() bool {
	if len(mmFail.expectations) == 0 && mmFail.defaultExpectation == nil && mmFail.mock.funcFail == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmFail.mock.afterFailCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmFail.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Fail implements mm_service.Orders
func (mmFail *OrdersMock) Fail(ctx context.Context, id int64) (err error) {
	mm_atomic.AddUint64(&mmFail.beforeFailCounter, 1)
	defer mm_atomic.AddUint64(&mmFail.afterFailCounter, 1)

	mmFail.t.Helper()

	if mmFail.inspectFuncFail != nil {
		mmFail.inspectFuncFail(ctx, id)
	}

	mm_params := OrdersMockFailParams{ctx, id}

	// Record call args
	mmFail.FailMock.mutex.Lock()
	mmFail.FailMock.callArgs = append(mmFail.FailMock.callArgs, &mm_params)
	mmFail.FailMock.mutex.Unlock()

	for _, e := range mmFail.FailMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmFail.FailMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFail.FailMock.defaultExpectation.Counter, 1)
		mm_want := mmFail.FailMock.defaultExpectation.params
		mm_want_ptrs := mmFail.FailMock.defaultExpectation.paramPtrs

		mm_got := OrdersMockFailParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmFail.t.Errorf("OrdersMock.Fail got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFail.FailMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmFail.t.Errorf("OrdersMock.Fail got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmFail.FailMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFail.t.Errorf("OrdersMock.Fail got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmFail.FailMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFail.FailMock.defaultExpectation.results
		if mm_results == nil {
			mmFail.t.Fatal("No results are set for the OrdersMock.Fail")
		}
		return (*mm_results).err
	}
	if mmFail.funcFail != nil {
		return mmFail.funcFail(ctx, id)
	}
	mmFail.t.Fatalf("Unexpected call to OrdersMock.Fail. %v %v", ctx, id)
	return
}

// FailAfterCounter returns a count of finished OrdersMock.Fail invocations
func (mmFail *OrdersMock) FailAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFail.afterFailCounter)
}

// FailBeforeCounter returns a count of OrdersMock.Fail invocations
func (mmFail *OrdersMock) FailBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFail.beforeFailCounter)
}

// Calls returns a list of arguments used in each call to OrdersMock.Fail.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFail *mOrdersMockFail) Calls() []*OrdersMockFailParams {
	mmFail.mutex.RLock()

	argCopy := make([]*OrdersMockFailParams, len(mmFail.callArgs))
	copy(argCopy, mmFail.callArgs)

	mmFail.mutex.RUnlock()

	return argCopy
}

// MinimockFailDone returns true if the count of the Fail invocations corresponds
// the number of defined expectations
func (m *OrdersMock) MinimockFailDone() bool {
	if m.FailMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.FailMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.FailMock.invocationsDone()
}

// MinimockFailInspect logs each unmet expectation
func (m *OrdersMock) MinimockFailInspect() {
	for _, e := range m.FailMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrdersMock.Fail at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterFailCounter := mm_atomic.LoadUint64(&m.afterFailCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.FailMock.defaultExpectation != nil && afterFailCounter < 1 {
		if m.FailMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrdersMock.Fail at\n%s", m.FailMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrdersMock.Fail at\n%s with params: %#v", m.FailMock.defaultExpectation.expectationOrigins.origin, *m.FailMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFail != nil && afterFailCounter < 1 {
		m.t.Errorf("Expected call to OrdersMock.Fail at\n%s", m.funcFailOrigin)
	}

	if !m.FailMock.invocationsDone() && afterFailCounter > 0 {
		m.t.Errorf("Expected %d calls to OrdersMock.Fail at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.FailMock.expectedInvocations), m.FailMock.expectedInvocationsOrigin, afterFailCounter)
	}
}

type mOrdersMockOrder struct {
	optional           bool
	mock               *OrdersMock
	defaultExpectation *OrdersMockOrderExpectation
	expectations       []*OrdersMockOrderExpectation

	callArgs []*OrdersMockOrderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrdersMockOrderExpectation specifies expectation struct of the Orders.Order
type OrdersMockOrderExpectation struct {
	mock               *OrdersMock
	params             *OrdersMockOrderParams
	paramPtrs          *OrdersMockOrderParamPtrs
	expectationOrigins OrdersMockOrderExpectationOrigins
	results            *OrdersMockOrderResults
	returnOrigin       string
	Counter            uint64
}

// OrdersMockOrderParams contains parameters of the Orders.Order
type OrdersMockOrderParams struct {
	ctx context.Context
	id  int64
}

// OrdersMockOrderParamPtrs contains pointers to parameters of the Orders.Order
type OrdersMockOrderParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// OrdersMockOrderResults contains results of the Orders.Order
type OrdersMockOrderResults struct {
	op1 *loms.Order
	err error
}

// OrdersMockOrderOrigins contains origins of expectations of the Orders.Order
type OrdersMockOrderExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmOrder *mOrdersMockOrder) Optional() *mOrdersMockOrder {
	mmOrder.optional = true
	return mmOrder
}

// Expect sets up expected params for Orders.Order
func (mmOrder *mOrdersMockOrder) Expect(ctx context.Context, id int64) *mOrdersMockOrder {
	if mmOrder.mock.funcOrder != nil {
		mmOrder.mock.t.Fatalf("OrdersMock.Order mock is already set by Set")
	}

	if mmOrder.defaultExpectation == nil {
		mmOrder.defaultExpectation = &OrdersMockOrderExpectation{}
	}

	if mmOrder.defaultExpectation.paramPtrs != nil {
		mmOrder.mock.t.Fatalf("OrdersMock.Order mock is already set by ExpectParams functions")
	}

	mmOrder.defaultExpectation.params = &OrdersMockOrderParams{ctx, id}
	mmOrder.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmOrder.expectations {
		if minimock.Equal(e.params, mmOrder.defaultExpectation.params) {
			mmOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmOrder.defaultExpectation.params)
		}
	}

	return mmOrder
}

// ExpectCtxParam1 sets up expected param ctx for Orders.Order
func (mmOrder *mOrdersMockOrder) ExpectCtxParam1(ctx context.Context) *mOrdersMockOrder {
	if mmOrder.mock.funcOrder != nil {
		mmOrder.mock.t.Fatalf("OrdersMock.Order mock is already set by Set")
	}

	if mmOrder.defaultExpectation == nil {
		mmOrder.defaultExpectation = &OrdersMockOrderExpectation{}
	}

	if mmOrder.defaultExpectation.params != nil {
		mmOrder.mock.t.Fatalf("OrdersMock.Order mock is already set by Expect")
	}

	if mmOrder.defaultExpectation.paramPtrs == nil {
		mmOrder.defaultExpectation.paramPtrs = &OrdersMockOrderParamPtrs{}
	}
	mmOrder.defaultExpectation.paramPtrs.ctx = &ctx
	mmOrder.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmOrder
}

// ExpectIdParam2 sets up expected param id for Orders.Order
func (mmOrder *mOrdersMockOrder) ExpectIdParam2(id int64) *mOrdersMockOrder {
	if mmOrder.mock.funcOrder != nil {
		mmOrder.mock.t.Fatalf("OrdersMock.Order mock is already set by Set")
	}

	if mmOrder.defaultExpectation == nil {
		mmOrder.defaultExpectation = &OrdersMockOrderExpectation{}
	}

	if mmOrder.defaultExpectation.params != nil {
		mmOrder.mock.t.Fatalf("OrdersMock.Order mock is already set by Expect")
	}

	if mmOrder.defaultExpectation.paramPtrs == nil {
		mmOrder.defaultExpectation.paramPtrs = &OrdersMockOrderParamPtrs{}
	}
	mmOrder.defaultExpectation.paramPtrs.id = &id
	mmOrder.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmOrder
}

// Inspect accepts an inspector function that has same arguments as the Orders.Order
func (mmOrder *mOrdersMockOrder) Inspect(f func(ctx context.Context, id int64)) *mOrdersMockOrder {
	if mmOrder.mock.inspectFuncOrder != nil {
		mmOrder.mock.t.Fatalf("Inspect function is already set for OrdersMock.Order")
	}

	mmOrder.mock.inspectFuncOrder = f

	return mmOrder
}

// Return sets up results that will be returned by Orders.Order
func (mmOrder *mOrdersMockOrder) Return(op1 *loms.Order, err error) *OrdersMock {
	if mmOrder.mock.funcOrder != nil {
		mmOrder.mock.t.Fatalf("OrdersMock.Order mock is already set by Set")
	}

	if mmOrder.defaultExpectation == nil {
		mmOrder.defaultExpectation = &OrdersMockOrderExpectation{mock: mmOrder.mock}
	}
	mmOrder.defaultExpectation.results = &OrdersMockOrderResults{op1, err}
	mmOrder.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmOrder.mock
}

// Set uses given function f to mock the Orders.Order method
func (mmOrder *mOrdersMockOrder) Set(f func(ctx context.Context, id int64) (op1 *loms.Order, err error)) *OrdersMock {
	if mmOrder.defaultExpectation != nil {
		mmOrder.mock.t.Fatalf("Default expectation is already set for the Orders.Order method")
	}

	if len(mmOrder.expectations) > 0 {
		mmOrder.mock.t.Fatalf("Some expectations are already set for the Orders.Order method")
	}

	mmOrder.mock.funcOrder = f
	mmOrder.mock.funcOrderOrigin = minimock.CallerInfo(1)
	return mmOrder.mock
}

// When sets expectation for the Orders.Order which will trigger the result defined by the following
// Then helper
func (mmOrder *mOrdersMockOrder) When(ctx context.Context, id int64) *OrdersMockOrderExpectation {
	if mmOrder.mock.funcOrder != nil {
		mmOrder.mock.t.Fatalf("OrdersMock.Order mock is already set by Set")
	}

	expectation := &OrdersMockOrderExpectation{
		mock:               mmOrder.mock,
		params:             &OrdersMockOrderParams{ctx, id},
		expectationOrigins: OrdersMockOrderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmOrder.expectations = append(mmOrder.expectations, expectation)
	return expectation
}

// Then sets up Orders.Order return parameters for the expectation previously defined by the When method
func (e *OrdersMockOrderExpectation) Then(op1 *loms.Order, err error) *OrdersMock {
	e.results = &OrdersMockOrderResults{op1, err}
	return e.mock
}

// Times sets number of times Orders.Order should be invoked
func (mmOrder *mOrdersMockOrder) Times(n uint64) *mOrdersMockOrder {
	if n == 0 {
		mmOrder.mock.t.Fatalf("Times of OrdersMock.Order mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmOrder.expectedInvocations, n)
	mmOrder.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmOrder
}

func (mmOrder *mOrdersMockOrder) invocationsDone() bool {
	if len(mmOrder.expectations) == 0 && mmOrder.defaultExpectation == nil && mmOrder.mock.funcOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmOrder.mock.afterOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Order implements mm_service.Orders
func (mmOrder *OrdersMock) Order(ctx context.Context, id int64) (op1 *loms.Order, err error) {
	mm_atomic.AddUint64(&mmOrder.beforeOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmOrder.afterOrderCounter, 1)

	mmOrder.t.Helper()

	if mmOrder.inspectFuncOrder != nil {
		mmOrder.inspectFuncOrder(ctx, id)
	}

	mm_params := OrdersMockOrderParams{ctx, id}

	// Record call args
	mmOrder.OrderMock.mutex.Lock()
	mmOrder.OrderMock.callArgs = append(mmOrder.OrderMock.callArgs, &mm_params)
	mmOrder.OrderMock.mutex.Unlock()

	for _, e := range mmOrder.OrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmOrder.OrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmOrder.OrderMock.defaultExpectation.Counter, 1)
		mm_want := mmOrder.OrderMock.defaultExpectation.params
		mm_want_ptrs := mmOrder.OrderMock.defaultExpectation.paramPtrs

		mm_got := OrdersMockOrderParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmOrder.t.Errorf("OrdersMock.Order got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmOrder.OrderMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmOrder.t.Errorf("OrdersMock.Order got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmOrder.OrderMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmOrder.t.Errorf("OrdersMock.Order got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmOrder.OrderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmOrder.OrderMock.defaultExpectation.results
		if mm_results == nil {
			mmOrder.t.Fatal("No results are set for the OrdersMock.Order")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmOrder.funcOrder != nil {
		return mmOrder.funcOrder(ctx, id)
	}
	mmOrder.t.Fatalf("Unexpected call to OrdersMock.Order. %v %v", ctx, id)
	return
}

// OrderAfterCounter returns a count of finished OrdersMock.Order invocations
func (mmOrder *OrdersMock) OrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrder.afterOrderCounter)
}

// OrderBeforeCounter returns a count of OrdersMock.Order invocations
func (mmOrder *OrdersMock) OrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmOrder.beforeOrderCounter)
}

// Calls returns a list of arguments used in each call to OrdersMock.Order.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmOrder *mOrdersMockOrder) Calls() []*OrdersMockOrderParams {
	mmOrder.mutex.RLock()

	argCopy := make([]*OrdersMockOrderParams, len(mmOrder.callArgs))
	copy(argCopy, mmOrder.callArgs)

	mmOrder.mutex.RUnlock()

	return argCopy
}

// MinimockOrderDone returns true if the count of the Order invocations corresponds
// the number of defined expectations
func (m *OrdersMock) MinimockOrderDone() bool {
	if m.OrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.OrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.OrderMock.invocationsDone()
}

// MinimockOrderInspect logs each unmet expectation
func (m *OrdersMock) MinimockOrderInspect() {
	for _, e := range m.OrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrdersMock.Order at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterOrderCounter := mm_atomic.LoadUint64(&m.afterOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.OrderMock.defaultExpectation != nil && afterOrderCounter < 1 {
		if m.OrderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrdersMock.Order at\n%s", m.OrderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrdersMock.Order at\n%s with params: %#v", m.OrderMock.defaultExpectation.expectationOrigins.origin, *m.OrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcOrder != nil && afterOrderCounter < 1 {
		m.t.Errorf("Expected call to OrdersMock.Order at\n%s", m.funcOrderOrigin)
	}

	if !m.OrderMock.invocationsDone() && afterOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to OrdersMock.Order at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.OrderMock.expectedInvocations), m.OrderMock.expectedInvocationsOrigin, afterOrderCounter)
	}
}

type mOrdersMockPay struct {
	optional           bool
	mock               *OrdersMock
	defaultExpectation *OrdersMockPayExpectation
	expectations       []*OrdersMockPayExpectation

	callArgs []*OrdersMockPayParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// OrdersMockPayExpectation specifies expectation struct of the Orders.Pay
type OrdersMockPayExpectation struct {
	mock               *OrdersMock
	params             *OrdersMockPayParams
	paramPtrs          *OrdersMockPayParamPtrs
	expectationOrigins OrdersMockPayExpectationOrigins
	results            *OrdersMockPayResults
	returnOrigin       string
	Counter            uint64
}

// OrdersMockPayParams contains parameters of the Orders.Pay
type OrdersMockPayParams struct {
	ctx context.Context
	id  int64
}

// OrdersMockPayParamPtrs contains pointers to parameters of the Orders.Pay
type OrdersMockPayParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// OrdersMockPayResults contains results of the Orders.Pay
type OrdersMockPayResults struct {
	err error
}

// OrdersMockPayOrigins contains origins of expectations of the Orders.Pay
type OrdersMockPayExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmPay *mOrdersMockPay) Optional() *mOrdersMockPay {
	mmPay.optional = true
	return mmPay
}

// Expect sets up expected params for Orders.Pay
func (mmPay *mOrdersMockPay) Expect(ctx context.Context, id int64) *mOrdersMockPay {
	if mmPay.mock.funcPay != nil {
		mmPay.mock.t.Fatalf("OrdersMock.Pay mock is already set by Set")
	}

	if mmPay.defaultExpectation == nil {
		mmPay.defaultExpectation = &OrdersMockPayExpectation{}
	}

	if mmPay.defaultExpectation.paramPtrs != nil {
		mmPay.mock.t.Fatalf("OrdersMock.Pay mock is already set by ExpectParams functions")
	}

	mmPay.defaultExpectation.params = &OrdersMockPayParams{ctx, id}
	mmPay.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmPay.expectations {
		if minimock.Equal(e.params, mmPay.defaultExpectation.params) {
			mmPay.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPay.defaultExpectation.params)
		}
	}

	return mmPay
}

// ExpectCtxParam1 sets up expected param ctx for Orders.Pay
func (mmPay *mOrdersMockPay) ExpectCtxParam1(ctx context.Context) *mOrdersMockPay {
	if mmPay.mock.funcPay != nil {
		mmPay.mock.t.Fatalf("OrdersMock.Pay mock is already set by Set")
	}

	if mmPay.defaultExpectation == nil {
		mmPay.defaultExpectation = &OrdersMockPayExpectation{}
	}

	if mmPay.defaultExpectation.params != nil {
		mmPay.mock.t.Fatalf("OrdersMock.Pay mock is already set by Expect")
	}

	if mmPay.defaultExpectation.paramPtrs == nil {
		mmPay.defaultExpectation.paramPtrs = &OrdersMockPayParamPtrs{}
	}
	mmPay.defaultExpectation.paramPtrs.ctx = &ctx
	mmPay.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmPay
}

// ExpectIdParam2 sets up expected param id for Orders.Pay
func (mmPay *mOrdersMockPay) ExpectIdParam2(id int64) *mOrdersMockPay {
	if mmPay.mock.funcPay != nil {
		mmPay.mock.t.Fatalf("OrdersMock.Pay mock is already set by Set")
	}

	if mmPay.defaultExpectation == nil {
		mmPay.defaultExpectation = &OrdersMockPayExpectation{}
	}

	if mmPay.defaultExpectation.params != nil {
		mmPay.mock.t.Fatalf("OrdersMock.Pay mock is already set by Expect")
	}

	if mmPay.defaultExpectation.paramPtrs == nil {
		mmPay.defaultExpectation.paramPtrs = &OrdersMockPayParamPtrs{}
	}
	mmPay.defaultExpectation.paramPtrs.id = &id
	mmPay.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmPay
}

// Inspect accepts an inspector function that has same arguments as the Orders.Pay
func (mmPay *mOrdersMockPay) Inspect(f func(ctx context.Context, id int64)) *mOrdersMockPay {
	if mmPay.mock.inspectFuncPay != nil {
		mmPay.mock.t.Fatalf("Inspect function is already set for OrdersMock.Pay")
	}

	mmPay.mock.inspectFuncPay = f

	return mmPay
}

// Return sets up results that will be returned by Orders.Pay
func (mmPay *mOrdersMockPay) Return(err error) *OrdersMock {
	if mmPay.mock.funcPay != nil {
		mmPay.mock.t.Fatalf("OrdersMock.Pay mock is already set by Set")
	}

	if mmPay.defaultExpectation == nil {
		mmPay.defaultExpectation = &OrdersMockPayExpectation{mock: mmPay.mock}
	}
	mmPay.defaultExpectation.results = &OrdersMockPayResults{err}
	mmPay.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmPay.mock
}

// Set uses given function f to mock the Orders.Pay method
func (mmPay *mOrdersMockPay) Set(f func(ctx context.Context, id int64) (err error)) *OrdersMock {
	if mmPay.defaultExpectation != nil {
		mmPay.mock.t.Fatalf("Default expectation is already set for the Orders.Pay method")
	}

	if len(mmPay.expectations) > 0 {
		mmPay.mock.t.Fatalf("Some expectations are already set for the Orders.Pay method")
	}

	mmPay.mock.funcPay = f
	mmPay.mock.funcPayOrigin = minimock.CallerInfo(1)
	return mmPay.mock
}

// When sets expectation for the Orders.Pay which will trigger the result defined by the following
// Then helper
func (mmPay *mOrdersMockPay) When(ctx context.Context, id int64) *OrdersMockPayExpectation {
	if mmPay.mock.funcPay != nil {
		mmPay.mock.t.Fatalf("OrdersMock.Pay mock is already set by Set")
	}

	expectation := &OrdersMockPayExpectation{
		mock:               mmPay.mock,
		params:             &OrdersMockPayParams{ctx, id},
		expectationOrigins: OrdersMockPayExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmPay.expectations = append(mmPay.expectations, expectation)
	return expectation
}

// Then sets up Orders.Pay return parameters for the expectation previously defined by the When method
func (e *OrdersMockPayExpectation) Then(err error) *OrdersMock {
	e.results = &OrdersMockPayResults{err}
	return e.mock
}

// Times sets number of times Orders.Pay should be invoked
func (mmPay *mOrdersMockPay) Times(n uint64) *mOrdersMockPay {
	if n == 0 {
		mmPay.mock.t.Fatalf("Times of OrdersMock.Pay mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmPay.expectedInvocations, n)
	mmPay.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmPay
}

func (mmPay *mOrdersMockPay) invocationsDone() bool {
	if len(mmPay.expectations) == 0 && mmPay.defaultExpectation == nil && mmPay.mock.funcPay == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmPay.mock.afterPayCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmPay.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Pay implements mm_service.Orders
func (mmPay *OrdersMock) Pay(ctx context.Context, id int64) (err error) {
	mm_atomic.AddUint64(&mmPay.beforePayCounter, 1)
	defer mm_atomic.AddUint64(&mmPay.afterPayCounter, 1)

	mmPay.t.Helper()

	if mmPay.inspectFuncPay != nil {
		mmPay.inspectFuncPay(ctx, id)
	}

	mm_params := OrdersMockPayParams{ctx, id}

	// Record call args
	mmPay.PayMock.mutex.Lock()
	mmPay.PayMock.callArgs = append(mmPay.PayMock.callArgs, &mm_params)
	mmPay.PayMock.mutex.Unlock()

	for _, e := range mmPay.PayMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmPay.PayMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPay.PayMock.defaultExpectation.Counter, 1)
		mm_want := mmPay.PayMock.defaultExpectation.params
		mm_want_ptrs := mmPay.PayMock.defaultExpectation.paramPtrs

		mm_got := OrdersMockPayParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmPay.t.Errorf("OrdersMock.Pay got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPay.PayMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmPay.t.Errorf("OrdersMock.Pay got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmPay.PayMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPay.t.Errorf("OrdersMock.Pay got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmPay.PayMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPay.PayMock.defaultExpectation.results
		if mm_results == nil {
			mmPay.t.Fatal("No results are set for the OrdersMock.Pay")
		}
		return (*mm_results).err
	}
	if mmPay.funcPay != nil {
		return mmPay.funcPay(ctx, id)
	}
	mmPay.t.Fatalf("Unexpected call to OrdersMock.Pay. %v %v", ctx, id)
	return
}

// PayAfterCounter returns a count of finished OrdersMock.Pay invocations
func (mmPay *OrdersMock) PayAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPay.afterPayCounter)
}

// PayBeforeCounter returns a count of OrdersMock.Pay invocations
func (mmPay *OrdersMock) PayBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPay.beforePayCounter)
}

// Calls returns a list of arguments used in each call to OrdersMock.Pay.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPay *mOrdersMockPay) Calls() []*OrdersMockPayParams {
	mmPay.mutex.RLock()

	argCopy := make([]*OrdersMockPayParams, len(mmPay.callArgs))
	copy(argCopy, mmPay.callArgs)

	mmPay.mutex.RUnlock()

	return argCopy
}

// MinimockPayDone returns true if the count of the Pay invocations corresponds
// the number of defined expectations
func (m *OrdersMock) MinimockPayDone() bool {
	if m.PayMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.PayMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.PayMock.invocationsDone()
}

// MinimockPayInspect logs each unmet expectation
func (m *OrdersMock) MinimockPayInspect() {
	for _, e := range m.PayMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrdersMock.Pay at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterPayCounter := mm_atomic.LoadUint64(&m.afterPayCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.PayMock.defaultExpectation != nil && afterPayCounter < 1 {
		if m.PayMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to OrdersMock.Pay at\n%s", m.PayMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to OrdersMock.Pay at\n%s with params: %#v", m.PayMock.defaultExpectation.expectationOrigins.origin, *m.PayMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPay != nil && afterPayCounter < 1 {
		m.t.Errorf("Expected call to OrdersMock.Pay at\n%s", m.funcPayOrigin)
	}

	if !m.PayMock.invocationsDone() && afterPayCounter > 0 {
		m.t.Errorf("Expected %d calls to OrdersMock.Pay at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.PayMock.expectedInvocations), m.PayMock.expectedInvocationsOrigin, afterPayCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *OrdersMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAwaitingPaymentInspect()

			m.MinimockCancelInspect()

			m.MinimockCreateInspect()

			m.MinimockFailInspect()

			m.MinimockOrderInspect()

			m.MinimockPayInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *OrdersMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *OrdersMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAwaitingPaymentDone() &&
		m.MinimockCancelDone() &&
		m.MinimockCreateDone() &&
		m.MinimockFailDone() &&
		m.MinimockOrderDone() &&
		m.MinimockPayDone()
}
