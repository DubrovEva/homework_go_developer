// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocked

//go:generate minimock -i route256/loms/internal/service.Stocks -o stocks_mock.go -n StocksMock -p mocked

import (
	"context"
	loms "route256/loms/pkg/api/loms/v1"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// StocksMock implements mm_service.Stocks
type StocksMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAvailableStocks          func(ctx context.Context, sku int64) (u1 uint32, err error)
	funcAvailableStocksOrigin    string
	inspectFuncAvailableStocks   func(ctx context.Context, sku int64)
	afterAvailableStocksCounter  uint64
	beforeAvailableStocksCounter uint64
	AvailableStocksMock          mStocksMockAvailableStocks

	funcRelease          func(ctx context.Context, items []*loms.Item) (err error)
	funcReleaseOrigin    string
	inspectFuncRelease   func(ctx context.Context, items []*loms.Item)
	afterReleaseCounter  uint64
	beforeReleaseCounter uint64
	ReleaseMock          mStocksMockRelease

	funcReserve          func(ctx context.Context, items []*loms.Item) (err error)
	funcReserveOrigin    string
	inspectFuncReserve   func(ctx context.Context, items []*loms.Item)
	afterReserveCounter  uint64
	beforeReserveCounter uint64
	ReserveMock          mStocksMockReserve

	funcSell          func(ctx context.Context, items []*loms.Item) (err error)
	funcSellOrigin    string
	inspectFuncSell   func(ctx context.Context, items []*loms.Item)
	afterSellCounter  uint64
	beforeSellCounter uint64
	SellMock          mStocksMockSell
}

// NewStocksMock returns a mock for mm_service.Stocks
func NewStocksMock(t minimock.Tester) *StocksMock {
	m := &StocksMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AvailableStocksMock = mStocksMockAvailableStocks{mock: m}
	m.AvailableStocksMock.callArgs = []*StocksMockAvailableStocksParams{}

	m.ReleaseMock = mStocksMockRelease{mock: m}
	m.ReleaseMock.callArgs = []*StocksMockReleaseParams{}

	m.ReserveMock = mStocksMockReserve{mock: m}
	m.ReserveMock.callArgs = []*StocksMockReserveParams{}

	m.SellMock = mStocksMockSell{mock: m}
	m.SellMock.callArgs = []*StocksMockSellParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mStocksMockAvailableStocks struct {
	optional           bool
	mock               *StocksMock
	defaultExpectation *StocksMockAvailableStocksExpectation
	expectations       []*StocksMockAvailableStocksExpectation

	callArgs []*StocksMockAvailableStocksParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StocksMockAvailableStocksExpectation specifies expectation struct of the Stocks.AvailableStocks
type StocksMockAvailableStocksExpectation struct {
	mock               *StocksMock
	params             *StocksMockAvailableStocksParams
	paramPtrs          *StocksMockAvailableStocksParamPtrs
	expectationOrigins StocksMockAvailableStocksExpectationOrigins
	results            *StocksMockAvailableStocksResults
	returnOrigin       string
	Counter            uint64
}

// StocksMockAvailableStocksParams contains parameters of the Stocks.AvailableStocks
type StocksMockAvailableStocksParams struct {
	ctx context.Context
	sku int64
}

// StocksMockAvailableStocksParamPtrs contains pointers to parameters of the Stocks.AvailableStocks
type StocksMockAvailableStocksParamPtrs struct {
	ctx *context.Context
	sku *int64
}

// StocksMockAvailableStocksResults contains results of the Stocks.AvailableStocks
type StocksMockAvailableStocksResults struct {
	u1  uint32
	err error
}

// StocksMockAvailableStocksOrigins contains origins of expectations of the Stocks.AvailableStocks
type StocksMockAvailableStocksExpectationOrigins struct {
	origin    string
	originCtx string
	originSku string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAvailableStocks *mStocksMockAvailableStocks) Optional() *mStocksMockAvailableStocks {
	mmAvailableStocks.optional = true
	return mmAvailableStocks
}

// Expect sets up expected params for Stocks.AvailableStocks
func (mmAvailableStocks *mStocksMockAvailableStocks) Expect(ctx context.Context, sku int64) *mStocksMockAvailableStocks {
	if mmAvailableStocks.mock.funcAvailableStocks != nil {
		mmAvailableStocks.mock.t.Fatalf("StocksMock.AvailableStocks mock is already set by Set")
	}

	if mmAvailableStocks.defaultExpectation == nil {
		mmAvailableStocks.defaultExpectation = &StocksMockAvailableStocksExpectation{}
	}

	if mmAvailableStocks.defaultExpectation.paramPtrs != nil {
		mmAvailableStocks.mock.t.Fatalf("StocksMock.AvailableStocks mock is already set by ExpectParams functions")
	}

	mmAvailableStocks.defaultExpectation.params = &StocksMockAvailableStocksParams{ctx, sku}
	mmAvailableStocks.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAvailableStocks.expectations {
		if minimock.Equal(e.params, mmAvailableStocks.defaultExpectation.params) {
			mmAvailableStocks.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAvailableStocks.defaultExpectation.params)
		}
	}

	return mmAvailableStocks
}

// ExpectCtxParam1 sets up expected param ctx for Stocks.AvailableStocks
func (mmAvailableStocks *mStocksMockAvailableStocks) ExpectCtxParam1(ctx context.Context) *mStocksMockAvailableStocks {
	if mmAvailableStocks.mock.funcAvailableStocks != nil {
		mmAvailableStocks.mock.t.Fatalf("StocksMock.AvailableStocks mock is already set by Set")
	}

	if mmAvailableStocks.defaultExpectation == nil {
		mmAvailableStocks.defaultExpectation = &StocksMockAvailableStocksExpectation{}
	}

	if mmAvailableStocks.defaultExpectation.params != nil {
		mmAvailableStocks.mock.t.Fatalf("StocksMock.AvailableStocks mock is already set by Expect")
	}

	if mmAvailableStocks.defaultExpectation.paramPtrs == nil {
		mmAvailableStocks.defaultExpectation.paramPtrs = &StocksMockAvailableStocksParamPtrs{}
	}
	mmAvailableStocks.defaultExpectation.paramPtrs.ctx = &ctx
	mmAvailableStocks.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAvailableStocks
}

// ExpectSkuParam2 sets up expected param sku for Stocks.AvailableStocks
func (mmAvailableStocks *mStocksMockAvailableStocks) ExpectSkuParam2(sku int64) *mStocksMockAvailableStocks {
	if mmAvailableStocks.mock.funcAvailableStocks != nil {
		mmAvailableStocks.mock.t.Fatalf("StocksMock.AvailableStocks mock is already set by Set")
	}

	if mmAvailableStocks.defaultExpectation == nil {
		mmAvailableStocks.defaultExpectation = &StocksMockAvailableStocksExpectation{}
	}

	if mmAvailableStocks.defaultExpectation.params != nil {
		mmAvailableStocks.mock.t.Fatalf("StocksMock.AvailableStocks mock is already set by Expect")
	}

	if mmAvailableStocks.defaultExpectation.paramPtrs == nil {
		mmAvailableStocks.defaultExpectation.paramPtrs = &StocksMockAvailableStocksParamPtrs{}
	}
	mmAvailableStocks.defaultExpectation.paramPtrs.sku = &sku
	mmAvailableStocks.defaultExpectation.expectationOrigins.originSku = minimock.CallerInfo(1)

	return mmAvailableStocks
}

// Inspect accepts an inspector function that has same arguments as the Stocks.AvailableStocks
func (mmAvailableStocks *mStocksMockAvailableStocks) Inspect(f func(ctx context.Context, sku int64)) *mStocksMockAvailableStocks {
	if mmAvailableStocks.mock.inspectFuncAvailableStocks != nil {
		mmAvailableStocks.mock.t.Fatalf("Inspect function is already set for StocksMock.AvailableStocks")
	}

	mmAvailableStocks.mock.inspectFuncAvailableStocks = f

	return mmAvailableStocks
}

// Return sets up results that will be returned by Stocks.AvailableStocks
func (mmAvailableStocks *mStocksMockAvailableStocks) Return(u1 uint32, err error) *StocksMock {
	if mmAvailableStocks.mock.funcAvailableStocks != nil {
		mmAvailableStocks.mock.t.Fatalf("StocksMock.AvailableStocks mock is already set by Set")
	}

	if mmAvailableStocks.defaultExpectation == nil {
		mmAvailableStocks.defaultExpectation = &StocksMockAvailableStocksExpectation{mock: mmAvailableStocks.mock}
	}
	mmAvailableStocks.defaultExpectation.results = &StocksMockAvailableStocksResults{u1, err}
	mmAvailableStocks.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAvailableStocks.mock
}

// Set uses given function f to mock the Stocks.AvailableStocks method
func (mmAvailableStocks *mStocksMockAvailableStocks) Set(f func(ctx context.Context, sku int64) (u1 uint32, err error)) *StocksMock {
	if mmAvailableStocks.defaultExpectation != nil {
		mmAvailableStocks.mock.t.Fatalf("Default expectation is already set for the Stocks.AvailableStocks method")
	}

	if len(mmAvailableStocks.expectations) > 0 {
		mmAvailableStocks.mock.t.Fatalf("Some expectations are already set for the Stocks.AvailableStocks method")
	}

	mmAvailableStocks.mock.funcAvailableStocks = f
	mmAvailableStocks.mock.funcAvailableStocksOrigin = minimock.CallerInfo(1)
	return mmAvailableStocks.mock
}

// When sets expectation for the Stocks.AvailableStocks which will trigger the result defined by the following
// Then helper
func (mmAvailableStocks *mStocksMockAvailableStocks) When(ctx context.Context, sku int64) *StocksMockAvailableStocksExpectation {
	if mmAvailableStocks.mock.funcAvailableStocks != nil {
		mmAvailableStocks.mock.t.Fatalf("StocksMock.AvailableStocks mock is already set by Set")
	}

	expectation := &StocksMockAvailableStocksExpectation{
		mock:               mmAvailableStocks.mock,
		params:             &StocksMockAvailableStocksParams{ctx, sku},
		expectationOrigins: StocksMockAvailableStocksExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAvailableStocks.expectations = append(mmAvailableStocks.expectations, expectation)
	return expectation
}

// Then sets up Stocks.AvailableStocks return parameters for the expectation previously defined by the When method
func (e *StocksMockAvailableStocksExpectation) Then(u1 uint32, err error) *StocksMock {
	e.results = &StocksMockAvailableStocksResults{u1, err}
	return e.mock
}

// Times sets number of times Stocks.AvailableStocks should be invoked
func (mmAvailableStocks *mStocksMockAvailableStocks) Times(n uint64) *mStocksMockAvailableStocks {
	if n == 0 {
		mmAvailableStocks.mock.t.Fatalf("Times of StocksMock.AvailableStocks mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAvailableStocks.expectedInvocations, n)
	mmAvailableStocks.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAvailableStocks
}

func (mmAvailableStocks *mStocksMockAvailableStocks) invocationsDone() bool {
	if len(mmAvailableStocks.expectations) == 0 && mmAvailableStocks.defaultExpectation == nil && mmAvailableStocks.mock.funcAvailableStocks == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAvailableStocks.mock.afterAvailableStocksCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAvailableStocks.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AvailableStocks implements mm_service.Stocks
func (mmAvailableStocks *StocksMock) AvailableStocks(ctx context.Context, sku int64) (u1 uint32, err error) {
	mm_atomic.AddUint64(&mmAvailableStocks.beforeAvailableStocksCounter, 1)
	defer mm_atomic.AddUint64(&mmAvailableStocks.afterAvailableStocksCounter, 1)

	mmAvailableStocks.t.Helper()

	if mmAvailableStocks.inspectFuncAvailableStocks != nil {
		mmAvailableStocks.inspectFuncAvailableStocks(ctx, sku)
	}

	mm_params := StocksMockAvailableStocksParams{ctx, sku}

	// Record call args
	mmAvailableStocks.AvailableStocksMock.mutex.Lock()
	mmAvailableStocks.AvailableStocksMock.callArgs = append(mmAvailableStocks.AvailableStocksMock.callArgs, &mm_params)
	mmAvailableStocks.AvailableStocksMock.mutex.Unlock()

	for _, e := range mmAvailableStocks.AvailableStocksMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmAvailableStocks.AvailableStocksMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAvailableStocks.AvailableStocksMock.defaultExpectation.Counter, 1)
		mm_want := mmAvailableStocks.AvailableStocksMock.defaultExpectation.params
		mm_want_ptrs := mmAvailableStocks.AvailableStocksMock.defaultExpectation.paramPtrs

		mm_got := StocksMockAvailableStocksParams{ctx, sku}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAvailableStocks.t.Errorf("StocksMock.AvailableStocks got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAvailableStocks.AvailableStocksMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.sku != nil && !minimock.Equal(*mm_want_ptrs.sku, mm_got.sku) {
				mmAvailableStocks.t.Errorf("StocksMock.AvailableStocks got unexpected parameter sku, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAvailableStocks.AvailableStocksMock.defaultExpectation.expectationOrigins.originSku, *mm_want_ptrs.sku, mm_got.sku, minimock.Diff(*mm_want_ptrs.sku, mm_got.sku))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAvailableStocks.t.Errorf("StocksMock.AvailableStocks got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAvailableStocks.AvailableStocksMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAvailableStocks.AvailableStocksMock.defaultExpectation.results
		if mm_results == nil {
			mmAvailableStocks.t.Fatal("No results are set for the StocksMock.AvailableStocks")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmAvailableStocks.funcAvailableStocks != nil {
		return mmAvailableStocks.funcAvailableStocks(ctx, sku)
	}
	mmAvailableStocks.t.Fatalf("Unexpected call to StocksMock.AvailableStocks. %v %v", ctx, sku)
	return
}

// AvailableStocksAfterCounter returns a count of finished StocksMock.AvailableStocks invocations
func (mmAvailableStocks *StocksMock) AvailableStocksAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAvailableStocks.afterAvailableStocksCounter)
}

// AvailableStocksBeforeCounter returns a count of StocksMock.AvailableStocks invocations
func (mmAvailableStocks *StocksMock) AvailableStocksBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAvailableStocks.beforeAvailableStocksCounter)
}

// Calls returns a list of arguments used in each call to StocksMock.AvailableStocks.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAvailableStocks *mStocksMockAvailableStocks) Calls() []*StocksMockAvailableStocksParams {
	mmAvailableStocks.mutex.RLock()

	argCopy := make([]*StocksMockAvailableStocksParams, len(mmAvailableStocks.callArgs))
	copy(argCopy, mmAvailableStocks.callArgs)

	mmAvailableStocks.mutex.RUnlock()

	return argCopy
}

// MinimockAvailableStocksDone returns true if the count of the AvailableStocks invocations corresponds
// the number of defined expectations
func (m *StocksMock) MinimockAvailableStocksDone() bool {
	if m.AvailableStocksMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AvailableStocksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AvailableStocksMock.invocationsDone()
}

// MinimockAvailableStocksInspect logs each unmet expectation
func (m *StocksMock) MinimockAvailableStocksInspect() {
	for _, e := range m.AvailableStocksMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StocksMock.AvailableStocks at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAvailableStocksCounter := mm_atomic.LoadUint64(&m.afterAvailableStocksCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AvailableStocksMock.defaultExpectation != nil && afterAvailableStocksCounter < 1 {
		if m.AvailableStocksMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StocksMock.AvailableStocks at\n%s", m.AvailableStocksMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StocksMock.AvailableStocks at\n%s with params: %#v", m.AvailableStocksMock.defaultExpectation.expectationOrigins.origin, *m.AvailableStocksMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAvailableStocks != nil && afterAvailableStocksCounter < 1 {
		m.t.Errorf("Expected call to StocksMock.AvailableStocks at\n%s", m.funcAvailableStocksOrigin)
	}

	if !m.AvailableStocksMock.invocationsDone() && afterAvailableStocksCounter > 0 {
		m.t.Errorf("Expected %d calls to StocksMock.AvailableStocks at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AvailableStocksMock.expectedInvocations), m.AvailableStocksMock.expectedInvocationsOrigin, afterAvailableStocksCounter)
	}
}

type mStocksMockRelease struct {
	optional           bool
	mock               *StocksMock
	defaultExpectation *StocksMockReleaseExpectation
	expectations       []*StocksMockReleaseExpectation

	callArgs []*StocksMockReleaseParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StocksMockReleaseExpectation specifies expectation struct of the Stocks.Release
type StocksMockReleaseExpectation struct {
	mock               *StocksMock
	params             *StocksMockReleaseParams
	paramPtrs          *StocksMockReleaseParamPtrs
	expectationOrigins StocksMockReleaseExpectationOrigins
	results            *StocksMockReleaseResults
	returnOrigin       string
	Counter            uint64
}

// StocksMockReleaseParams contains parameters of the Stocks.Release
type StocksMockReleaseParams struct {
	ctx   context.Context
	items []*loms.Item
}

// StocksMockReleaseParamPtrs contains pointers to parameters of the Stocks.Release
type StocksMockReleaseParamPtrs struct {
	ctx   *context.Context
	items *[]*loms.Item
}

// StocksMockReleaseResults contains results of the Stocks.Release
type StocksMockReleaseResults struct {
	err error
}

// StocksMockReleaseOrigins contains origins of expectations of the Stocks.Release
type StocksMockReleaseExpectationOrigins struct {
	origin      string
	originCtx   string
	originItems string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRelease *mStocksMockRelease) Optional() *mStocksMockRelease {
	mmRelease.optional = true
	return mmRelease
}

// Expect sets up expected params for Stocks.Release
func (mmRelease *mStocksMockRelease) Expect(ctx context.Context, items []*loms.Item) *mStocksMockRelease {
	if mmRelease.mock.funcRelease != nil {
		mmRelease.mock.t.Fatalf("StocksMock.Release mock is already set by Set")
	}

	if mmRelease.defaultExpectation == nil {
		mmRelease.defaultExpectation = &StocksMockReleaseExpectation{}
	}

	if mmRelease.defaultExpectation.paramPtrs != nil {
		mmRelease.mock.t.Fatalf("StocksMock.Release mock is already set by ExpectParams functions")
	}

	mmRelease.defaultExpectation.params = &StocksMockReleaseParams{ctx, items}
	mmRelease.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRelease.expectations {
		if minimock.Equal(e.params, mmRelease.defaultExpectation.params) {
			mmRelease.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRelease.defaultExpectation.params)
		}
	}

	return mmRelease
}

// ExpectCtxParam1 sets up expected param ctx for Stocks.Release
func (mmRelease *mStocksMockRelease) ExpectCtxParam1(ctx context.Context) *mStocksMockRelease {
	if mmRelease.mock.funcRelease != nil {
		mmRelease.mock.t.Fatalf("StocksMock.Release mock is already set by Set")
	}

	if mmRelease.defaultExpectation == nil {
		mmRelease.defaultExpectation = &StocksMockReleaseExpectation{}
	}

	if mmRelease.defaultExpectation.params != nil {
		mmRelease.mock.t.Fatalf("StocksMock.Release mock is already set by Expect")
	}

	if mmRelease.defaultExpectation.paramPtrs == nil {
		mmRelease.defaultExpectation.paramPtrs = &StocksMockReleaseParamPtrs{}
	}
	mmRelease.defaultExpectation.paramPtrs.ctx = &ctx
	mmRelease.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRelease
}

// ExpectItemsParam2 sets up expected param items for Stocks.Release
func (mmRelease *mStocksMockRelease) ExpectItemsParam2(items []*loms.Item) *mStocksMockRelease {
	if mmRelease.mock.funcRelease != nil {
		mmRelease.mock.t.Fatalf("StocksMock.Release mock is already set by Set")
	}

	if mmRelease.defaultExpectation == nil {
		mmRelease.defaultExpectation = &StocksMockReleaseExpectation{}
	}

	if mmRelease.defaultExpectation.params != nil {
		mmRelease.mock.t.Fatalf("StocksMock.Release mock is already set by Expect")
	}

	if mmRelease.defaultExpectation.paramPtrs == nil {
		mmRelease.defaultExpectation.paramPtrs = &StocksMockReleaseParamPtrs{}
	}
	mmRelease.defaultExpectation.paramPtrs.items = &items
	mmRelease.defaultExpectation.expectationOrigins.originItems = minimock.CallerInfo(1)

	return mmRelease
}

// Inspect accepts an inspector function that has same arguments as the Stocks.Release
func (mmRelease *mStocksMockRelease) Inspect(f func(ctx context.Context, items []*loms.Item)) *mStocksMockRelease {
	if mmRelease.mock.inspectFuncRelease != nil {
		mmRelease.mock.t.Fatalf("Inspect function is already set for StocksMock.Release")
	}

	mmRelease.mock.inspectFuncRelease = f

	return mmRelease
}

// Return sets up results that will be returned by Stocks.Release
func (mmRelease *mStocksMockRelease) Return(err error) *StocksMock {
	if mmRelease.mock.funcRelease != nil {
		mmRelease.mock.t.Fatalf("StocksMock.Release mock is already set by Set")
	}

	if mmRelease.defaultExpectation == nil {
		mmRelease.defaultExpectation = &StocksMockReleaseExpectation{mock: mmRelease.mock}
	}
	mmRelease.defaultExpectation.results = &StocksMockReleaseResults{err}
	mmRelease.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRelease.mock
}

// Set uses given function f to mock the Stocks.Release method
func (mmRelease *mStocksMockRelease) Set(f func(ctx context.Context, items []*loms.Item) (err error)) *StocksMock {
	if mmRelease.defaultExpectation != nil {
		mmRelease.mock.t.Fatalf("Default expectation is already set for the Stocks.Release method")
	}

	if len(mmRelease.expectations) > 0 {
		mmRelease.mock.t.Fatalf("Some expectations are already set for the Stocks.Release method")
	}

	mmRelease.mock.funcRelease = f
	mmRelease.mock.funcReleaseOrigin = minimock.CallerInfo(1)
	return mmRelease.mock
}

// When sets expectation for the Stocks.Release which will trigger the result defined by the following
// Then helper
func (mmRelease *mStocksMockRelease) When(ctx context.Context, items []*loms.Item) *StocksMockReleaseExpectation {
	if mmRelease.mock.funcRelease != nil {
		mmRelease.mock.t.Fatalf("StocksMock.Release mock is already set by Set")
	}

	expectation := &StocksMockReleaseExpectation{
		mock:               mmRelease.mock,
		params:             &StocksMockReleaseParams{ctx, items},
		expectationOrigins: StocksMockReleaseExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRelease.expectations = append(mmRelease.expectations, expectation)
	return expectation
}

// Then sets up Stocks.Release return parameters for the expectation previously defined by the When method
func (e *StocksMockReleaseExpectation) Then(err error) *StocksMock {
	e.results = &StocksMockReleaseResults{err}
	return e.mock
}

// Times sets number of times Stocks.Release should be invoked
func (mmRelease *mStocksMockRelease) Times(n uint64) *mStocksMockRelease {
	if n == 0 {
		mmRelease.mock.t.Fatalf("Times of StocksMock.Release mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRelease.expectedInvocations, n)
	mmRelease.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRelease
}

func (mmRelease *mStocksMockRelease) invocationsDone() bool {
	if len(mmRelease.expectations) == 0 && mmRelease.defaultExpectation == nil && mmRelease.mock.funcRelease == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRelease.mock.afterReleaseCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRelease.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Release implements mm_service.Stocks
func (mmRelease *StocksMock) Release(ctx context.Context, items []*loms.Item) (err error) {
	mm_atomic.AddUint64(&mmRelease.beforeReleaseCounter, 1)
	defer mm_atomic.AddUint64(&mmRelease.afterReleaseCounter, 1)

	mmRelease.t.Helper()

	if mmRelease.inspectFuncRelease != nil {
		mmRelease.inspectFuncRelease(ctx, items)
	}

	mm_params := StocksMockReleaseParams{ctx, items}

	// Record call args
	mmRelease.ReleaseMock.mutex.Lock()
	mmRelease.ReleaseMock.callArgs = append(mmRelease.ReleaseMock.callArgs, &mm_params)
	mmRelease.ReleaseMock.mutex.Unlock()

	for _, e := range mmRelease.ReleaseMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRelease.ReleaseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRelease.ReleaseMock.defaultExpectation.Counter, 1)
		mm_want := mmRelease.ReleaseMock.defaultExpectation.params
		mm_want_ptrs := mmRelease.ReleaseMock.defaultExpectation.paramPtrs

		mm_got := StocksMockReleaseParams{ctx, items}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRelease.t.Errorf("StocksMock.Release got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRelease.ReleaseMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.items != nil && !minimock.Equal(*mm_want_ptrs.items, mm_got.items) {
				mmRelease.t.Errorf("StocksMock.Release got unexpected parameter items, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRelease.ReleaseMock.defaultExpectation.expectationOrigins.originItems, *mm_want_ptrs.items, mm_got.items, minimock.Diff(*mm_want_ptrs.items, mm_got.items))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRelease.t.Errorf("StocksMock.Release got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRelease.ReleaseMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRelease.ReleaseMock.defaultExpectation.results
		if mm_results == nil {
			mmRelease.t.Fatal("No results are set for the StocksMock.Release")
		}
		return (*mm_results).err
	}
	if mmRelease.funcRelease != nil {
		return mmRelease.funcRelease(ctx, items)
	}
	mmRelease.t.Fatalf("Unexpected call to StocksMock.Release. %v %v", ctx, items)
	return
}

// ReleaseAfterCounter returns a count of finished StocksMock.Release invocations
func (mmRelease *StocksMock) ReleaseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRelease.afterReleaseCounter)
}

// ReleaseBeforeCounter returns a count of StocksMock.Release invocations
func (mmRelease *StocksMock) ReleaseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRelease.beforeReleaseCounter)
}

// Calls returns a list of arguments used in each call to StocksMock.Release.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRelease *mStocksMockRelease) Calls() []*StocksMockReleaseParams {
	mmRelease.mutex.RLock()

	argCopy := make([]*StocksMockReleaseParams, len(mmRelease.callArgs))
	copy(argCopy, mmRelease.callArgs)

	mmRelease.mutex.RUnlock()

	return argCopy
}

// MinimockReleaseDone returns true if the count of the Release invocations corresponds
// the number of defined expectations
func (m *StocksMock) MinimockReleaseDone() bool {
	if m.ReleaseMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReleaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReleaseMock.invocationsDone()
}

// MinimockReleaseInspect logs each unmet expectation
func (m *StocksMock) MinimockReleaseInspect() {
	for _, e := range m.ReleaseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StocksMock.Release at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReleaseCounter := mm_atomic.LoadUint64(&m.afterReleaseCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReleaseMock.defaultExpectation != nil && afterReleaseCounter < 1 {
		if m.ReleaseMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StocksMock.Release at\n%s", m.ReleaseMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StocksMock.Release at\n%s with params: %#v", m.ReleaseMock.defaultExpectation.expectationOrigins.origin, *m.ReleaseMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRelease != nil && afterReleaseCounter < 1 {
		m.t.Errorf("Expected call to StocksMock.Release at\n%s", m.funcReleaseOrigin)
	}

	if !m.ReleaseMock.invocationsDone() && afterReleaseCounter > 0 {
		m.t.Errorf("Expected %d calls to StocksMock.Release at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReleaseMock.expectedInvocations), m.ReleaseMock.expectedInvocationsOrigin, afterReleaseCounter)
	}
}

type mStocksMockReserve struct {
	optional           bool
	mock               *StocksMock
	defaultExpectation *StocksMockReserveExpectation
	expectations       []*StocksMockReserveExpectation

	callArgs []*StocksMockReserveParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StocksMockReserveExpectation specifies expectation struct of the Stocks.Reserve
type StocksMockReserveExpectation struct {
	mock               *StocksMock
	params             *StocksMockReserveParams
	paramPtrs          *StocksMockReserveParamPtrs
	expectationOrigins StocksMockReserveExpectationOrigins
	results            *StocksMockReserveResults
	returnOrigin       string
	Counter            uint64
}

// StocksMockReserveParams contains parameters of the Stocks.Reserve
type StocksMockReserveParams struct {
	ctx   context.Context
	items []*loms.Item
}

// StocksMockReserveParamPtrs contains pointers to parameters of the Stocks.Reserve
type StocksMockReserveParamPtrs struct {
	ctx   *context.Context
	items *[]*loms.Item
}

// StocksMockReserveResults contains results of the Stocks.Reserve
type StocksMockReserveResults struct {
	err error
}

// StocksMockReserveOrigins contains origins of expectations of the Stocks.Reserve
type StocksMockReserveExpectationOrigins struct {
	origin      string
	originCtx   string
	originItems string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReserve *mStocksMockReserve) Optional() *mStocksMockReserve {
	mmReserve.optional = true
	return mmReserve
}

// Expect sets up expected params for Stocks.Reserve
func (mmReserve *mStocksMockReserve) Expect(ctx context.Context, items []*loms.Item) *mStocksMockReserve {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("StocksMock.Reserve mock is already set by Set")
	}

	if mmReserve.defaultExpectation == nil {
		mmReserve.defaultExpectation = &StocksMockReserveExpectation{}
	}

	if mmReserve.defaultExpectation.paramPtrs != nil {
		mmReserve.mock.t.Fatalf("StocksMock.Reserve mock is already set by ExpectParams functions")
	}

	mmReserve.defaultExpectation.params = &StocksMockReserveParams{ctx, items}
	mmReserve.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmReserve.expectations {
		if minimock.Equal(e.params, mmReserve.defaultExpectation.params) {
			mmReserve.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReserve.defaultExpectation.params)
		}
	}

	return mmReserve
}

// ExpectCtxParam1 sets up expected param ctx for Stocks.Reserve
func (mmReserve *mStocksMockReserve) ExpectCtxParam1(ctx context.Context) *mStocksMockReserve {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("StocksMock.Reserve mock is already set by Set")
	}

	if mmReserve.defaultExpectation == nil {
		mmReserve.defaultExpectation = &StocksMockReserveExpectation{}
	}

	if mmReserve.defaultExpectation.params != nil {
		mmReserve.mock.t.Fatalf("StocksMock.Reserve mock is already set by Expect")
	}

	if mmReserve.defaultExpectation.paramPtrs == nil {
		mmReserve.defaultExpectation.paramPtrs = &StocksMockReserveParamPtrs{}
	}
	mmReserve.defaultExpectation.paramPtrs.ctx = &ctx
	mmReserve.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmReserve
}

// ExpectItemsParam2 sets up expected param items for Stocks.Reserve
func (mmReserve *mStocksMockReserve) ExpectItemsParam2(items []*loms.Item) *mStocksMockReserve {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("StocksMock.Reserve mock is already set by Set")
	}

	if mmReserve.defaultExpectation == nil {
		mmReserve.defaultExpectation = &StocksMockReserveExpectation{}
	}

	if mmReserve.defaultExpectation.params != nil {
		mmReserve.mock.t.Fatalf("StocksMock.Reserve mock is already set by Expect")
	}

	if mmReserve.defaultExpectation.paramPtrs == nil {
		mmReserve.defaultExpectation.paramPtrs = &StocksMockReserveParamPtrs{}
	}
	mmReserve.defaultExpectation.paramPtrs.items = &items
	mmReserve.defaultExpectation.expectationOrigins.originItems = minimock.CallerInfo(1)

	return mmReserve
}

// Inspect accepts an inspector function that has same arguments as the Stocks.Reserve
func (mmReserve *mStocksMockReserve) Inspect(f func(ctx context.Context, items []*loms.Item)) *mStocksMockReserve {
	if mmReserve.mock.inspectFuncReserve != nil {
		mmReserve.mock.t.Fatalf("Inspect function is already set for StocksMock.Reserve")
	}

	mmReserve.mock.inspectFuncReserve = f

	return mmReserve
}

// Return sets up results that will be returned by Stocks.Reserve
func (mmReserve *mStocksMockReserve) Return(err error) *StocksMock {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("StocksMock.Reserve mock is already set by Set")
	}

	if mmReserve.defaultExpectation == nil {
		mmReserve.defaultExpectation = &StocksMockReserveExpectation{mock: mmReserve.mock}
	}
	mmReserve.defaultExpectation.results = &StocksMockReserveResults{err}
	mmReserve.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReserve.mock
}

// Set uses given function f to mock the Stocks.Reserve method
func (mmReserve *mStocksMockReserve) Set(f func(ctx context.Context, items []*loms.Item) (err error)) *StocksMock {
	if mmReserve.defaultExpectation != nil {
		mmReserve.mock.t.Fatalf("Default expectation is already set for the Stocks.Reserve method")
	}

	if len(mmReserve.expectations) > 0 {
		mmReserve.mock.t.Fatalf("Some expectations are already set for the Stocks.Reserve method")
	}

	mmReserve.mock.funcReserve = f
	mmReserve.mock.funcReserveOrigin = minimock.CallerInfo(1)
	return mmReserve.mock
}

// When sets expectation for the Stocks.Reserve which will trigger the result defined by the following
// Then helper
func (mmReserve *mStocksMockReserve) When(ctx context.Context, items []*loms.Item) *StocksMockReserveExpectation {
	if mmReserve.mock.funcReserve != nil {
		mmReserve.mock.t.Fatalf("StocksMock.Reserve mock is already set by Set")
	}

	expectation := &StocksMockReserveExpectation{
		mock:               mmReserve.mock,
		params:             &StocksMockReserveParams{ctx, items},
		expectationOrigins: StocksMockReserveExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmReserve.expectations = append(mmReserve.expectations, expectation)
	return expectation
}

// Then sets up Stocks.Reserve return parameters for the expectation previously defined by the When method
func (e *StocksMockReserveExpectation) Then(err error) *StocksMock {
	e.results = &StocksMockReserveResults{err}
	return e.mock
}

// Times sets number of times Stocks.Reserve should be invoked
func (mmReserve *mStocksMockReserve) Times(n uint64) *mStocksMockReserve {
	if n == 0 {
		mmReserve.mock.t.Fatalf("Times of StocksMock.Reserve mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReserve.expectedInvocations, n)
	mmReserve.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReserve
}

func (mmReserve *mStocksMockReserve) invocationsDone() bool {
	if len(mmReserve.expectations) == 0 && mmReserve.defaultExpectation == nil && mmReserve.mock.funcReserve == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReserve.mock.afterReserveCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReserve.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Reserve implements mm_service.Stocks
func (mmReserve *StocksMock) Reserve(ctx context.Context, items []*loms.Item) (err error) {
	mm_atomic.AddUint64(&mmReserve.beforeReserveCounter, 1)
	defer mm_atomic.AddUint64(&mmReserve.afterReserveCounter, 1)

	mmReserve.t.Helper()

	if mmReserve.inspectFuncReserve != nil {
		mmReserve.inspectFuncReserve(ctx, items)
	}

	mm_params := StocksMockReserveParams{ctx, items}

	// Record call args
	mmReserve.ReserveMock.mutex.Lock()
	mmReserve.ReserveMock.callArgs = append(mmReserve.ReserveMock.callArgs, &mm_params)
	mmReserve.ReserveMock.mutex.Unlock()

	for _, e := range mmReserve.ReserveMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmReserve.ReserveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReserve.ReserveMock.defaultExpectation.Counter, 1)
		mm_want := mmReserve.ReserveMock.defaultExpectation.params
		mm_want_ptrs := mmReserve.ReserveMock.defaultExpectation.paramPtrs

		mm_got := StocksMockReserveParams{ctx, items}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReserve.t.Errorf("StocksMock.Reserve got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReserve.ReserveMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.items != nil && !minimock.Equal(*mm_want_ptrs.items, mm_got.items) {
				mmReserve.t.Errorf("StocksMock.Reserve got unexpected parameter items, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReserve.ReserveMock.defaultExpectation.expectationOrigins.originItems, *mm_want_ptrs.items, mm_got.items, minimock.Diff(*mm_want_ptrs.items, mm_got.items))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReserve.t.Errorf("StocksMock.Reserve got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmReserve.ReserveMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReserve.ReserveMock.defaultExpectation.results
		if mm_results == nil {
			mmReserve.t.Fatal("No results are set for the StocksMock.Reserve")
		}
		return (*mm_results).err
	}
	if mmReserve.funcReserve != nil {
		return mmReserve.funcReserve(ctx, items)
	}
	mmReserve.t.Fatalf("Unexpected call to StocksMock.Reserve. %v %v", ctx, items)
	return
}

// ReserveAfterCounter returns a count of finished StocksMock.Reserve invocations
func (mmReserve *StocksMock) ReserveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserve.afterReserveCounter)
}

// ReserveBeforeCounter returns a count of StocksMock.Reserve invocations
func (mmReserve *StocksMock) ReserveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReserve.beforeReserveCounter)
}

// Calls returns a list of arguments used in each call to StocksMock.Reserve.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReserve *mStocksMockReserve) Calls() []*StocksMockReserveParams {
	mmReserve.mutex.RLock()

	argCopy := make([]*StocksMockReserveParams, len(mmReserve.callArgs))
	copy(argCopy, mmReserve.callArgs)

	mmReserve.mutex.RUnlock()

	return argCopy
}

// MinimockReserveDone returns true if the count of the Reserve invocations corresponds
// the number of defined expectations
func (m *StocksMock) MinimockReserveDone() bool {
	if m.ReserveMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReserveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReserveMock.invocationsDone()
}

// MinimockReserveInspect logs each unmet expectation
func (m *StocksMock) MinimockReserveInspect() {
	for _, e := range m.ReserveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StocksMock.Reserve at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReserveCounter := mm_atomic.LoadUint64(&m.afterReserveCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReserveMock.defaultExpectation != nil && afterReserveCounter < 1 {
		if m.ReserveMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StocksMock.Reserve at\n%s", m.ReserveMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StocksMock.Reserve at\n%s with params: %#v", m.ReserveMock.defaultExpectation.expectationOrigins.origin, *m.ReserveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReserve != nil && afterReserveCounter < 1 {
		m.t.Errorf("Expected call to StocksMock.Reserve at\n%s", m.funcReserveOrigin)
	}

	if !m.ReserveMock.invocationsDone() && afterReserveCounter > 0 {
		m.t.Errorf("Expected %d calls to StocksMock.Reserve at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReserveMock.expectedInvocations), m.ReserveMock.expectedInvocationsOrigin, afterReserveCounter)
	}
}

type mStocksMockSell struct {
	optional           bool
	mock               *StocksMock
	defaultExpectation *StocksMockSellExpectation
	expectations       []*StocksMockSellExpectation

	callArgs []*StocksMockSellParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StocksMockSellExpectation specifies expectation struct of the Stocks.Sell
type StocksMockSellExpectation struct {
	mock               *StocksMock
	params             *StocksMockSellParams
	paramPtrs          *StocksMockSellParamPtrs
	expectationOrigins StocksMockSellExpectationOrigins
	results            *StocksMockSellResults
	returnOrigin       string
	Counter            uint64
}

// StocksMockSellParams contains parameters of the Stocks.Sell
type StocksMockSellParams struct {
	ctx   context.Context
	items []*loms.Item
}

// StocksMockSellParamPtrs contains pointers to parameters of the Stocks.Sell
type StocksMockSellParamPtrs struct {
	ctx   *context.Context
	items *[]*loms.Item
}

// StocksMockSellResults contains results of the Stocks.Sell
type StocksMockSellResults struct {
	err error
}

// StocksMockSellOrigins contains origins of expectations of the Stocks.Sell
type StocksMockSellExpectationOrigins struct {
	origin      string
	originCtx   string
	originItems string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSell *mStocksMockSell) Optional() *mStocksMockSell {
	mmSell.optional = true
	return mmSell
}

// Expect sets up expected params for Stocks.Sell
func (mmSell *mStocksMockSell) Expect(ctx context.Context, items []*loms.Item) *mStocksMockSell {
	if mmSell.mock.funcSell != nil {
		mmSell.mock.t.Fatalf("StocksMock.Sell mock is already set by Set")
	}

	if mmSell.defaultExpectation == nil {
		mmSell.defaultExpectation = &StocksMockSellExpectation{}
	}

	if mmSell.defaultExpectation.paramPtrs != nil {
		mmSell.mock.t.Fatalf("StocksMock.Sell mock is already set by ExpectParams functions")
	}

	mmSell.defaultExpectation.params = &StocksMockSellParams{ctx, items}
	mmSell.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSell.expectations {
		if minimock.Equal(e.params, mmSell.defaultExpectation.params) {
			mmSell.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSell.defaultExpectation.params)
		}
	}

	return mmSell
}

// ExpectCtxParam1 sets up expected param ctx for Stocks.Sell
func (mmSell *mStocksMockSell) ExpectCtxParam1(ctx context.Context) *mStocksMockSell {
	if mmSell.mock.funcSell != nil {
		mmSell.mock.t.Fatalf("StocksMock.Sell mock is already set by Set")
	}

	if mmSell.defaultExpectation == nil {
		mmSell.defaultExpectation = &StocksMockSellExpectation{}
	}

	if mmSell.defaultExpectation.params != nil {
		mmSell.mock.t.Fatalf("StocksMock.Sell mock is already set by Expect")
	}

	if mmSell.defaultExpectation.paramPtrs == nil {
		mmSell.defaultExpectation.paramPtrs = &StocksMockSellParamPtrs{}
	}
	mmSell.defaultExpectation.paramPtrs.ctx = &ctx
	mmSell.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSell
}

// ExpectItemsParam2 sets up expected param items for Stocks.Sell
func (mmSell *mStocksMockSell) ExpectItemsParam2(items []*loms.Item) *mStocksMockSell {
	if mmSell.mock.funcSell != nil {
		mmSell.mock.t.Fatalf("StocksMock.Sell mock is already set by Set")
	}

	if mmSell.defaultExpectation == nil {
		mmSell.defaultExpectation = &StocksMockSellExpectation{}
	}

	if mmSell.defaultExpectation.params != nil {
		mmSell.mock.t.Fatalf("StocksMock.Sell mock is already set by Expect")
	}

	if mmSell.defaultExpectation.paramPtrs == nil {
		mmSell.defaultExpectation.paramPtrs = &StocksMockSellParamPtrs{}
	}
	mmSell.defaultExpectation.paramPtrs.items = &items
	mmSell.defaultExpectation.expectationOrigins.originItems = minimock.CallerInfo(1)

	return mmSell
}

// Inspect accepts an inspector function that has same arguments as the Stocks.Sell
func (mmSell *mStocksMockSell) Inspect(f func(ctx context.Context, items []*loms.Item)) *mStocksMockSell {
	if mmSell.mock.inspectFuncSell != nil {
		mmSell.mock.t.Fatalf("Inspect function is already set for StocksMock.Sell")
	}

	mmSell.mock.inspectFuncSell = f

	return mmSell
}

// Return sets up results that will be returned by Stocks.Sell
func (mmSell *mStocksMockSell) Return(err error) *StocksMock {
	if mmSell.mock.funcSell != nil {
		mmSell.mock.t.Fatalf("StocksMock.Sell mock is already set by Set")
	}

	if mmSell.defaultExpectation == nil {
		mmSell.defaultExpectation = &StocksMockSellExpectation{mock: mmSell.mock}
	}
	mmSell.defaultExpectation.results = &StocksMockSellResults{err}
	mmSell.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSell.mock
}

// Set uses given function f to mock the Stocks.Sell method
func (mmSell *mStocksMockSell) Set(f func(ctx context.Context, items []*loms.Item) (err error)) *StocksMock {
	if mmSell.defaultExpectation != nil {
		mmSell.mock.t.Fatalf("Default expectation is already set for the Stocks.Sell method")
	}

	if len(mmSell.expectations) > 0 {
		mmSell.mock.t.Fatalf("Some expectations are already set for the Stocks.Sell method")
	}

	mmSell.mock.funcSell = f
	mmSell.mock.funcSellOrigin = minimock.CallerInfo(1)
	return mmSell.mock
}

// When sets expectation for the Stocks.Sell which will trigger the result defined by the following
// Then helper
func (mmSell *mStocksMockSell) When(ctx context.Context, items []*loms.Item) *StocksMockSellExpectation {
	if mmSell.mock.funcSell != nil {
		mmSell.mock.t.Fatalf("StocksMock.Sell mock is already set by Set")
	}

	expectation := &StocksMockSellExpectation{
		mock:               mmSell.mock,
		params:             &StocksMockSellParams{ctx, items},
		expectationOrigins: StocksMockSellExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSell.expectations = append(mmSell.expectations, expectation)
	return expectation
}

// Then sets up Stocks.Sell return parameters for the expectation previously defined by the When method
func (e *StocksMockSellExpectation) Then(err error) *StocksMock {
	e.results = &StocksMockSellResults{err}
	return e.mock
}

// Times sets number of times Stocks.Sell should be invoked
func (mmSell *mStocksMockSell) Times(n uint64) *mStocksMockSell {
	if n == 0 {
		mmSell.mock.t.Fatalf("Times of StocksMock.Sell mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSell.expectedInvocations, n)
	mmSell.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSell
}

func (mmSell *mStocksMockSell) invocationsDone() bool {
	if len(mmSell.expectations) == 0 && mmSell.defaultExpectation == nil && mmSell.mock.funcSell == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSell.mock.afterSellCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSell.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Sell implements mm_service.Stocks
func (mmSell *StocksMock) Sell(ctx context.Context, items []*loms.Item) (err error) {
	mm_atomic.AddUint64(&mmSell.beforeSellCounter, 1)
	defer mm_atomic.AddUint64(&mmSell.afterSellCounter, 1)

	mmSell.t.Helper()

	if mmSell.inspectFuncSell != nil {
		mmSell.inspectFuncSell(ctx, items)
	}

	mm_params := StocksMockSellParams{ctx, items}

	// Record call args
	mmSell.SellMock.mutex.Lock()
	mmSell.SellMock.callArgs = append(mmSell.SellMock.callArgs, &mm_params)
	mmSell.SellMock.mutex.Unlock()

	for _, e := range mmSell.SellMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSell.SellMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSell.SellMock.defaultExpectation.Counter, 1)
		mm_want := mmSell.SellMock.defaultExpectation.params
		mm_want_ptrs := mmSell.SellMock.defaultExpectation.paramPtrs

		mm_got := StocksMockSellParams{ctx, items}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSell.t.Errorf("StocksMock.Sell got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSell.SellMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.items != nil && !minimock.Equal(*mm_want_ptrs.items, mm_got.items) {
				mmSell.t.Errorf("StocksMock.Sell got unexpected parameter items, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSell.SellMock.defaultExpectation.expectationOrigins.originItems, *mm_want_ptrs.items, mm_got.items, minimock.Diff(*mm_want_ptrs.items, mm_got.items))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSell.t.Errorf("StocksMock.Sell got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSell.SellMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSell.SellMock.defaultExpectation.results
		if mm_results == nil {
			mmSell.t.Fatal("No results are set for the StocksMock.Sell")
		}
		return (*mm_results).err
	}
	if mmSell.funcSell != nil {
		return mmSell.funcSell(ctx, items)
	}
	mmSell.t.Fatalf("Unexpected call to StocksMock.Sell. %v %v", ctx, items)
	return
}

// SellAfterCounter returns a count of finished StocksMock.Sell invocations
func (mmSell *StocksMock) SellAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSell.afterSellCounter)
}

// SellBeforeCounter returns a count of StocksMock.Sell invocations
func (mmSell *StocksMock) SellBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSell.beforeSellCounter)
}

// Calls returns a list of arguments used in each call to StocksMock.Sell.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSell *mStocksMockSell) Calls() []*StocksMockSellParams {
	mmSell.mutex.RLock()

	argCopy := make([]*StocksMockSellParams, len(mmSell.callArgs))
	copy(argCopy, mmSell.callArgs)

	mmSell.mutex.RUnlock()

	return argCopy
}

// MinimockSellDone returns true if the count of the Sell invocations corresponds
// the number of defined expectations
func (m *StocksMock) MinimockSellDone() bool {
	if m.SellMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SellMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SellMock.invocationsDone()
}

// MinimockSellInspect logs each unmet expectation
func (m *StocksMock) MinimockSellInspect() {
	for _, e := range m.SellMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StocksMock.Sell at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSellCounter := mm_atomic.LoadUint64(&m.afterSellCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SellMock.defaultExpectation != nil && afterSellCounter < 1 {
		if m.SellMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StocksMock.Sell at\n%s", m.SellMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StocksMock.Sell at\n%s with params: %#v", m.SellMock.defaultExpectation.expectationOrigins.origin, *m.SellMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSell != nil && afterSellCounter < 1 {
		m.t.Errorf("Expected call to StocksMock.Sell at\n%s", m.funcSellOrigin)
	}

	if !m.SellMock.invocationsDone() && afterSellCounter > 0 {
		m.t.Errorf("Expected %d calls to StocksMock.Sell at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SellMock.expectedInvocations), m.SellMock.expectedInvocationsOrigin, afterSellCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StocksMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAvailableStocksInspect()

			m.MinimockReleaseInspect()

			m.MinimockReserveInspect()

			m.MinimockSellInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StocksMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StocksMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAvailableStocksDone() &&
		m.MinimockReleaseDone() &&
		m.MinimockReserveDone() &&
		m.MinimockSellDone()
}
